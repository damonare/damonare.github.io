<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Damonare的个人博客</title>
  <subtitle>不念过去，不畏将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://damonare.github.io/"/>
  <updated>2016-09-17T05:38:26.646Z</updated>
  <id>http://damonare.github.io/</id>
  
  <author>
    <name>Damonare</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/"/>
    <id>http://damonare.github.io/2016/09/16/十大经典排序算法总结（javascript描述）/</id>
    <published>2016-09-16T06:39:04.538Z</published>
    <updated>2016-09-17T05:38:26.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>读者自行尝试可以<a href="https://github.com/damonare/Sorts" target="_blank" rel="external">想看源码戳这</a>，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦</strong></p>
<a id="more"></a>
<blockquote>
<ul>
<li>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，<mark>JavaScript可谓风头无两，已经坐上了头把交椅。</mark></li>
<li>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（<mark>十大排序算法或是和十大排序算法同等难度的</mark>），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</li>
<li>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。<br><img src="http://img.blog.csdn.net/20160916152402267" alt="大大"></li>
</ul>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an<br>输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a href="http://blog.csdn.net/booirror/article/details/7707551/" target="_blank" rel="external">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><img src="http://img.blog.csdn.net/20160916153212716" alt="这里写图片描述"></p>
<p><strong>图片名词解释：</strong><br>n: 数据规模<br>k:“桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><img src="http://img.blog.csdn.net/20160916154036887" alt="这里写图片描述"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>
<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>
<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>
<li><4>.重复步骤1~3，直到排序完成。</4></li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    for (var i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        for (var j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            if (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                var temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">var arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.log(bubbleSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进冒泡排序： </strong>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function bubbleSort2(arr) &#123;</div><div class="line">    console.time('改进后冒泡排序耗时');</div><div class="line">    var i = arr.length<span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变</span></div><div class="line">    while ( i&gt; <span class="number">0</span>) &#123;</div><div class="line">        var pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></div><div class="line">        for (var j= <span class="number">0</span>; j&lt; i; j++)</div><div class="line">            if (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                pos= j; <span class="comment">//记录交换的位置</span></div><div class="line">                var tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        i= pos; <span class="comment">//为下一趟排序作准备</span></div><div class="line">     &#125;</div><div class="line">     console.timeEnd('改进后冒泡排序耗时');</div><div class="line">     return arr;</div><div class="line">&#125;</div><div class="line">var arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.log(bubbleSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function bubbleSort3(arr3) &#123;</div><div class="line">    var low = <span class="number">0</span>;</div><div class="line">    var high= arr.length<span class="number">-1</span>; <span class="comment">//设置变量的初始值</span></div><div class="line">    var tmp,j;</div><div class="line">    console.time('<span class="number">2.</span>改进后冒泡排序耗时');</div><div class="line">    while (low &lt; high) &#123;</div><div class="line">        for (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者</span></div><div class="line">            if (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        --high;                 <span class="comment">//修改high值, 前移一位</span></div><div class="line">        for (j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者</span></div><div class="line">            if (arr[j]&lt;arr[j<span class="number">-1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j<span class="number">-1</span>];arr[j<span class="number">-1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        ++low;                  <span class="comment">//修改low值,后移一位</span></div><div class="line">    &#125;</div><div class="line">    console.timeEnd('<span class="number">2.</span>改进后冒泡排序耗时');</div><div class="line">    return arr3;</div><div class="line">&#125;</div><div class="line">var arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.log(bubbleSort3(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure></p>
<p>三种方法耗时对比：</p>
<p><img src="http://img.blog.csdn.net/20160916163126374" alt="这里写图片描述"></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916160748389" alt="这里写图片描述"></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>
<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>
<li><3>.n-1趟结束，数组有序化了。</3></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function selectionSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    var minIndex, temp;</div><div class="line">    console.time('选择排序耗时');</div><div class="line">    for (var i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        for (var j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd('选择排序耗时');</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">var arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>选择排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916164754013" alt="这里写图片描述"></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p> 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>
<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>
<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>
<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>
<li><5>.将新元素插入到该位置后；</5></li>
<li><6>.重复步骤2~5。</6></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function insertionSort(<span class="built_in">array</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(<span class="built_in">array</span>).slice(<span class="number">8</span>, -<span class="number">1</span>) === 'Array') &#123;</div><div class="line">        console.<span class="built_in">time</span>('插入排序耗时：');</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">length</span>; i++) &#123;</div><div class="line">            <span class="built_in">var</span> <span class="built_in">key</span> = <span class="built_in">array</span>[i];</div><div class="line">            <span class="built_in">var</span> j = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; <span class="built_in">key</span>) &#123;</div><div class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">key</span>;</div><div class="line">        &#125;</div><div class="line">        console.timeEnd('插入排序耗时：');</div><div class="line">        <span class="built_in">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">return</span> '<span class="built_in">array</span> <span class="built_in">is</span> <span class="keyword">not</span> an Array!';</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function binaryInsertionSort(<span class="built_in">array</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(<span class="built_in">array</span>).slice(<span class="number">8</span>, -<span class="number">1</span>) === 'Array') &#123;</div><div class="line">        console.<span class="built_in">time</span>('二分插入排序耗时：');</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">length</span>; i++) &#123;</div><div class="line">            <span class="built_in">var</span> <span class="built_in">key</span> = <span class="built_in">array</span>[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                <span class="built_in">var</span> middle = parseInt((left + right) / <span class="number">2</span>);</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">key</span> &lt; <span class="built_in">array</span>[middle]) &#123;</div><div class="line">                    right = middle - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</div><div class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">array</span>[left] = <span class="built_in">key</span>;</div><div class="line">        &#125;</div><div class="line">        console.timeEnd('二分插入排序耗时：');</div><div class="line"></div><div class="line">        <span class="built_in">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">return</span> '<span class="built_in">array</span> <span class="built_in">is</span> <span class="keyword">not</span> an Array!';</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.<span class="built_in">log</span>(binaryInsertionSort(arr));//[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160916174656100" alt="这里写图片描述"></p>
<p><strong>插入排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916173802597" alt="这里写图片描述"></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明；<br>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>
<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>
<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">5</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">5</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">5</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(shellSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916235203417" alt="这里写图片描述"></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>
<li><2>.对这两个子序列分别采用归并排序；</2></li>
<li><3>.将两个排序好的子序列合并成一个最终的排序序列。</3></li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function mergeSort(arr) &#123;  <span class="comment">//采用自上而下的递归方法</span></div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> middle = <span class="type">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        <span class="keyword">left</span> = arr.slice(<span class="number">0</span>, middle),</div><div class="line">        <span class="keyword">right</span> = arr.slice(middle);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(<span class="keyword">left</span>), mergeSort(<span class="keyword">right</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function merge(<span class="keyword">left</span>, <span class="keyword">right</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    console.time('归并排序耗时');</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">left</span>.length &amp;&amp; <span class="keyword">right</span>.length) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">left</span>[<span class="number">0</span>] &lt;= <span class="keyword">right</span>[<span class="number">0</span>]) &#123;</div><div class="line">            result.push(<span class="keyword">left</span>.shift());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(<span class="keyword">right</span>.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">left</span>.length)</div><div class="line">        result.push(<span class="keyword">left</span>.shift());</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">right</span>.length)</div><div class="line">        result.push(<span class="keyword">right</span>.shift());</div><div class="line">    console.timeEnd('归并排序耗时');</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.log(mergeSort(arr));</div></pre></td></tr></table></figure>
<p><strong>归并排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160917001326254" alt="这里写图片描述"></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><1>.从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>
<li><2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>
<li><3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：快速排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line">//方法一</div><div class="line">function quickSort(<span class="built_in">array</span>, left, right) &#123;</div><div class="line">    console.<span class="built_in">time</span>('<span class="number">1</span>.快速排序耗时');</div><div class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(<span class="built_in">array</span>).slice(<span class="number">8</span>, -<span class="number">1</span>) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') &#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="built_in">var</span> x = <span class="built_in">array</span>[right], i = left - <span class="number">1</span>, temp;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">var</span> j = left; j &lt;= right; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt;= x) &#123;</div><div class="line">                    i++;</div><div class="line">                    temp = <span class="built_in">array</span>[i];</div><div class="line">                    <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</div><div class="line">                    <span class="built_in">array</span>[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            quickSort(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</div><div class="line">            quickSort(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">        console.timeEnd('<span class="number">1</span>.快速排序耗时');</div><div class="line">        <span class="built_in">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">return</span> '<span class="built_in">array</span> <span class="built_in">is</span> <span class="keyword">not</span> an Array <span class="keyword">or</span> left <span class="keyword">or</span> right <span class="built_in">is</span> <span class="keyword">not</span> a number!';</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//方法二</div><div class="line"><span class="built_in">var</span> quickSort2 = function(arr) &#123;</div><div class="line">    console.<span class="built_in">time</span>('<span class="number">2</span>.快速排序耗时');</div><div class="line">　　<span class="keyword">if</span> (arr.<span class="built_in">length</span> &lt;= <span class="number">1</span>) &#123; <span class="built_in">return</span> arr; &#125;</div><div class="line">　　<span class="built_in">var</span> pivotIndex = Math.<span class="built_in">floor</span>(arr.<span class="built_in">length</span> / <span class="number">2</span>);</div><div class="line">　　<span class="built_in">var</span> pivot = arr.<span class="built_in">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="built_in">var</span> left = [];</div><div class="line">　　<span class="built_in">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">length</span>; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.<span class="built_in">push</span>(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.<span class="built_in">push</span>(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">console.timeEnd('<span class="number">2</span>.快速排序耗时');</div><div class="line">　　<span class="built_in">return</span> quickSort2(left).<span class="built_in">concat</span>([pivot], quickSort2(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.<span class="built_in">log</span>(quickSort(arr,<span class="number">0</span>,arr.<span class="built_in">length</span>-<span class="number">1</span>));//[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</div><div class="line">console.<span class="built_in">log</span>(quickSort2(arr));//[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</div></pre></td></tr></table></figure>
<p><strong>快速排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917003004906" alt="快速排序"></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>
<li><2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>
<li><3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：堆排序</span></div><div class="line"><span class="doctag">@param</span>  array 待排序数组*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span><span class="params">(array)</span> </span>&#123;</div><div class="line">    console.time(<span class="string">'堆排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(<span class="keyword">array</span>).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="comment">//建堆</span></div><div class="line">        <span class="keyword">var</span> heapSize = <span class="keyword">array</span>.length, temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = Math.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            heapify(<span class="keyword">array</span>, i, heapSize);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">            temp = <span class="keyword">array</span>[<span class="number">0</span>];</div><div class="line">            <span class="keyword">array</span>[<span class="number">0</span>] = <span class="keyword">array</span>[j];</div><div class="line">            <span class="keyword">array</span>[j] = temp;</div><div class="line">            heapify(<span class="keyword">array</span>, <span class="number">0</span>, --heapSize);</div><div class="line">        &#125;</div><div class="line">        console.timeEnd(<span class="string">'堆排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">array</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*方法说明：维护堆的性质</span></div><div class="line"><span class="doctag">@param</span>  arr 数组</div><div class="line"><span class="doctag">@param</span>  x   数组下标</div><div class="line"><span class="doctag">@param</span>  len 堆大小*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span><span class="params">(arr, x, len)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(arr).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; typeof x === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> l = <span class="number">2</span> * x + <span class="number">1</span>, r = <span class="number">2</span> * x + <span class="number">2</span>, largest = x, temp;</div><div class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</div><div class="line">            largest = l;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (largest != x) &#123;</div><div class="line">            temp = arr[x];</div><div class="line">            arr[x] = arr[largest];</div><div class="line">            arr[largest] = temp;</div><div class="line">            heapify(arr, largest, len);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">91</span>,<span class="number">60</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">22</span>];</div><div class="line">console.log(heapSort(arr));<span class="comment">//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]</span></div></pre></td></tr></table></figure>
<p><strong>堆排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917105502853" alt="这里写图片描述"></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>. 找出待排序的数组中最大和最小的元素；</1></li>
<li><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></li>
<li><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></li>
<li><4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function countingSort(<span class="built_in">array</span>) &#123;</div><div class="line">    <span class="built_in">var</span> len = <span class="built_in">array</span>.<span class="built_in">length</span>,</div><div class="line">        B = [],</div><div class="line">        C = [],</div><div class="line">        <span class="built_in">min</span> = <span class="built_in">max</span> = <span class="built_in">array</span>[<span class="number">0</span>];</div><div class="line">    console.<span class="built_in">time</span>('计数排序耗时');</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="built_in">min</span> = <span class="built_in">min</span> &lt;= <span class="built_in">array</span>[i] ? <span class="built_in">min</span> : <span class="built_in">array</span>[i];</div><div class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &gt;= <span class="built_in">array</span>[i] ? <span class="built_in">max</span> : <span class="built_in">array</span>[i];</div><div class="line">        C[<span class="built_in">array</span>[i]] = C[<span class="built_in">array</span>[i]] ? C[<span class="built_in">array</span>[i]] + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> j = <span class="built_in">min</span>; j &lt; <span class="built_in">max</span>; j++) &#123;</div><div class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</div><div class="line">        B[C[<span class="built_in">array</span>[k]] - <span class="number">1</span>] = <span class="built_in">array</span>[k];</div><div class="line">        C[<span class="built_in">array</span>[k]]--;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd('计数排序耗时');</div><div class="line">    <span class="built_in">return</span> B;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line">console.<span class="built_in">log</span>(countingSort(arr)); //[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><img src="http://img.blog.csdn.net/20160917110641479" alt="这里写图片描述"></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.设置一个定量的数组当作空桶；</1></li>
<li><2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；</2></li>
<li><3>.对每个不是空的桶进行排序；</3></li>
<li><4>.从不是空的桶里把排好序的数据拼接起来。</4></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：桶排序</span></div><div class="line">@param  array 数组</div><div class="line">@param  num   桶的数量*/</div><div class="line">function bucketSort(<span class="built_in">array</span>, <span class="built_in">num</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.<span class="built_in">length</span> &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">var</span> len = <span class="built_in">array</span>.<span class="built_in">length</span>, buckets = [], result = [], <span class="built_in">min</span> = <span class="built_in">max</span> = <span class="built_in">array</span>[<span class="number">0</span>], regex = '/^[<span class="number">1</span>-<span class="number">9</span>]+[<span class="number">0</span>-<span class="number">9</span>]*$/', <span class="built_in">space</span>, n = <span class="number">0</span>;</div><div class="line">    <span class="built_in">num</span> = <span class="built_in">num</span> || ((<span class="built_in">num</span> &gt; <span class="number">1</span> &amp;&amp; regex.test(<span class="built_in">num</span>)) ? <span class="built_in">num</span> : <span class="number">10</span>);</div><div class="line">    console.<span class="built_in">time</span>('桶排序耗时');</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="built_in">min</span> = <span class="built_in">min</span> &lt;= <span class="built_in">array</span>[i] ? <span class="built_in">min</span> : <span class="built_in">array</span>[i];</div><div class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &gt;= <span class="built_in">array</span>[i] ? <span class="built_in">max</span> : <span class="built_in">array</span>[i];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">space</span> = (<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>) / <span class="built_in">num</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="built_in">var</span> index = Math.<span class="built_in">floor</span>((<span class="built_in">array</span>[j] - <span class="built_in">min</span>) / <span class="built_in">space</span>);</div><div class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   //  非空桶，插入排序</div><div class="line">            <span class="built_in">var</span> k = buckets[index].<span class="built_in">length</span> - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; <span class="built_in">array</span>[j]) &#123;</div><div class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + <span class="number">1</span>] = <span class="built_in">array</span>[j];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    //空桶，初始化</div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].<span class="built_in">push</span>(<span class="built_in">array</span>[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (n &lt; <span class="built_in">num</span>) &#123;</div><div class="line">        result = result.<span class="built_in">concat</span>(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd('桶排序耗时');</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line">console.<span class="built_in">log</span>(bucketSort(arr,<span class="number">4</span>));//[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</div></pre></td></tr></table></figure>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917111945979" alt="这里写图片描述"></p>
<p>关于桶排序<a href="http://www.cnblogs.com/lonelyxmas/p/3561938.html" target="_blank" rel="external">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.取得数组中的最大数，并取得位数；</1></li>
<li><2>.arr为原始数组，从最低位开始取每个位组成radix数组；</2></li>
<li><3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @author xiazdong</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line"><span class="comment">//LSD Radix Sort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</div><div class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> counter = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</div><div class="line">            <span class="keyword">if</span>(counter[bucket]== <span class="literal">null</span>) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917123313659" alt="这里写图片描述"></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;读者自行尝试可以&lt;a href=&quot;https://github.com/damonare/Sorts&quot;&gt;想看源码戳这&lt;/a&gt;，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://damonare.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Chrome控制台实用指南</title>
    <link href="http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/09/09/Chrome控制台使用总结/</id>
    <published>2016-09-09T12:43:11.000Z</published>
    <updated>2016-09-21T08:57:35.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。</p>
</blockquote>
<a id="more"></a>
<h2 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear"></a>console.clear</h2><blockquote>
<p>console.clear();清空控制台，这个应该和console.log知名度一样高吧。</p>
</blockquote>
<h2 id="console-log家族"><a href="#console-log家族" class="headerlink" title="console.log家族"></a>console.log家族</h2><blockquote>
<p>先简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台</p>
</blockquote>
<p><img src="http://img2.tuicool.com/I3EjMju.png!web" alt="这里写图片描述"></p>
<p>如果你是一位开发者，我想console.log肯定是经常使用的了，我们主要看看console.log的几个兄弟：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span><span class="selector-class">.console</span><span class="selector-class">.log</span> (<span class="string">'普通信息'</span>)</div><div class="line"></div><div class="line"><span class="number">2</span><span class="selector-class">.console</span><span class="selector-class">.info</span> (<span class="string">'提示性信息'</span>)</div><div class="line"></div><div class="line"><span class="number">3</span><span class="selector-class">.console</span><span class="selector-class">.error</span> (<span class="string">'错误信息'</span>)</div><div class="line"></div><div class="line"><span class="number">4</span><span class="selector-class">.console</span><span class="selector-class">.warn</span> (<span class="string">'警示信息'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909211537532" alt="控制台"></p>
<p><strong>大家都会用log，但很少有人能够很好地利用console.error , console.warn 等将输出到控制台的信息进行分类整理。他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。</strong></p>
<blockquote>
<p>如果再配合console.group 与console.groupEnd，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console<span class="selector-class">.group</span>(<span class="string">"app.bundle"</span>);</div><div class="line">console<span class="selector-class">.warn</span>(<span class="string">"来自bundle模块的警告信息1"</span>);console<span class="selector-class">.warn</span>(<span class="string">"来自bundle模块的警告信息2"</span>);</div><div class="line">console<span class="selector-class">.groupEnd</span>();</div><div class="line">console<span class="selector-class">.group</span>(<span class="string">"app.bundle"</span>);</div><div class="line">console<span class="selector-class">.log</span>(<span class="string">"来自bundle模块的信息1"</span>);console<span class="selector-class">.log</span>(<span class="string">"来自bundle模块的信息2"</span>);</div><div class="line">console<span class="selector-class">.groupEnd</span>();</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909212018524" alt="这里写图片描述"></p>
<p><strong>这样的控制台信息看上去就一目了然了，就不用再为了找这是属于那一行代码输出的再翻一遍源码了。</strong></p>
<blockquote>
<p>另外，console.log家族还给我们提供了一个的API：第一个参数可以带一些格式化指令，比如%c,\n;看下面这个炫酷的效果：</p>
</blockquote>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">log</span>('%chello world', '<span class="built_in">background</span>-<span class="built_in">image</span>:-webkit-gradient( <span class="built_in">linear</span>, left top, right top, <span class="built_in">color</span>-stop(<span class="number">0</span>, #f22), <span class="built_in">color</span>-stop(<span class="number">0.15</span>, #f2f), <span class="built_in">color</span>-stop(<span class="number">0.3</span>, #22f), <span class="built_in">color</span>-stop(<span class="number">0.45</span>, #2ff), <span class="built_in">color</span>-stop(<span class="number">0.6</span>, #2f2),<span class="built_in">color</span>-stop(<span class="number">0.75</span>, #2f2), <span class="built_in">color</span>-stop(<span class="number">0.9</span>, #ff2), <span class="built_in">color</span>-stop(<span class="number">1</span>, #f22) );<span class="built_in">color</span>:<span class="built_in">transparent</span>;-webkit-<span class="built_in">background</span>-clip: text;<span class="built_in">font</span>-size:5em;');</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909213512650" alt="这里写图片描述"></p>
<p><strong>当然，图片也是可以的，读者可以自行尝试，修改上述代码即可。</strong></p>
<blockquote>
<p>另外，console.log() 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p>
<p><img src="http://img.blog.csdn.net/20160909215338908" alt="这里写图片描述"></p>
</blockquote>
<h2 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h2><blockquote>
<p>看着这种“黑魔法”是不是有种坑分的感觉呢，其实还不止哦！console.table可以让我们输出表格,示例：</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> data = &#123;<span class="selector-tag">code</span>:<span class="number">200</span>,<span class="attribute">content</span>:[&#123;<span class="string">'品名'</span>: <span class="string">'杜雷斯'</span>, <span class="string">'数量'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'品名'</span>: <span class="string">'冈本'</span>, <span class="string">'数量'</span>: <span class="number">3</span>&#125;]&#125;;</div><div class="line">console.table(data.<span class="attribute">content</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909214911953" alt="这里写图片描述"></p>
<p><strong>有的时候后端传回来一大串数据，是不是觉得直接console.log或是通过抓包工具查看都会让人晕头转向呢，这个时候正事console.table发挥作用的时候了，以表格的形式呈现数据，自然一目了然。</strong></p>
<h2 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert"></a>console.assert</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isDebug=<span class="keyword">false</span>;</div><div class="line">console.<span class="keyword">assert</span>(isDebug,<span class="string">'开发中的log信息。。。'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写if或者三元表达式来达到目的，cosole.assert便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。</p>
<p><img src="http://img.blog.csdn.net/20160909215637362" alt="这里写图片描述"></p>
</blockquote>
<h2 id="console-count"><a href="#console-count" class="headerlink" title="console.count"></a>console.count</h2><blockquote>
<p>除了条件输出的场景，还有常见的场景是计数。<br>当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的console.count可以很地胜任这样的任务.</p>
<p><img src="http://img.blog.csdn.net/20160909215931738" alt="这里写图片描述"></p>
</blockquote>
<h2 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir"></a>console.dir</h2><blockquote>
<p>将DOM结点以JavaScript对象的形式输出到控制台<br>而console.log是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://img.blog.csdn.net/20160909220149156" alt="这里写图片描述"></p>
</blockquote>
<h2 id="console-time-amp-console-timeEnd"><a href="#console-time-amp-console-timeEnd" class="headerlink" title="console.time &amp; console.timeEnd"></a>console.time &amp; console.timeEnd</h2><blockquote>
<p>输出一些调试信息是控制台最常用的功能，当然，它的功能远不止于此。当做一些性能测试时，同样可以在这里很方便地进行。比如需要考量一段代码执行的耗时情况时，可以用console.time与 console.timeEnd来做此事。</p>
</blockquote>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">time</span>(<span class="string">"Array耗时"</span>);</div><div class="line"><span class="built_in">var</span> <span class="built_in">array</span>= <span class="built_in">new</span> Array(<span class="number">10000000</span>);</div><div class="line"><span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="built_in">array</span>.<span class="built_in">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = <span class="built_in">new</span> Object();</div><div class="line">&#125;;</div><div class="line">console.timeEnd(<span class="string">"Array耗时"</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909220932148" alt="这里写代码片"></p>
<blockquote>
<p>当想要查看CPU使用相关的信息时，可以使用console.profile配合 console.profileEnd来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是Profile。使用方法和console.time基本一样，其实time开发者工具里也有个tab就是timeline。关于console.prefile博主就不做多余的介绍了。想要做更多了解的读者可以看<a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#consolelogobject-object" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title="$"></a>$</h2><blockquote>
<p>讲真，米国程序员们真的很喜欢money啊（谁又不是呢），看看PHP就知道了,满屏的$符号。而在Chrome的控制台里，$用处同样是蛮多且方便的。</p>
</blockquote>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>+<span class="number">2</span><span class="comment">//回车，再</span></div><div class="line">$_+<span class="number">1</span><span class="comment">//回车得5</span></div></pre></td></tr></table></figure>
<blockquote>
<p>上面的</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$_</div></pre></td></tr></table></figure>
<blockquote>
<p>需要领悟其奥义才能使用得当，而</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$0~$4</div></pre></td></tr></table></figure>
<blockquote>
<p>则代表了最近5个你选择过的DOM节点。<br>什么意思呢？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160909222120965" alt="这里写图片描述"></p>
<blockquote>
<p>另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节点，多么滴熟悉。</p>
</blockquote>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span>(<span class="string">'body'</span>);</div><div class="line"><span class="symbol">$</span><span class="symbol">$</span>(<span class="string">'div'</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909223159417" alt="这里写图片描述"></p>
<blockquote>
<p>$(selector)返回的是满足选择条件的首个DOM元素。<br>剥去她伪善的外衣，其实$(selector)是原生JavaScript document.querySelector() 的封装。<br>同时另一个命令$$(selector)返回的是所有满足选择条件的元素的一个集合，是对document.querySelectorAll() 的封装。</p>
</blockquote>
<h2 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a>$x(path)</h2><blockquote>
<p>将所匹配的节点放在一个数组里返回</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$x</span>("<span class="comment">//p");</span></div><div class="line"><span class="variable">$x</span>("<span class="comment">//p[a]");</span></div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909232110728" alt="这里写图片描述"></p>
<blockquote>
<p>$x(“//p”)匹配所有的p节点，$x(“//p[a]”);匹配所有子节点包含a的p节点</p>
</blockquote>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">copy</span><span class="params">(document.body)</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>然后你就可以Ctrl+v了。</p>
</blockquote>
<p><strong>注意：他不依附于任何全局变量比如window，所以其实在JS代码里是访问不了这个copy方法的，所以从代码层面来调用复制功能也就无从谈起。但愿有天浏览器会提供相应的JS实现吧~这样我们就可以通过js代码进行复制操作而不用再依赖Flash插件了。</strong></p>
<h2 id="keys-amp-values"><a href="#keys-amp-values" class="headerlink" title="keys &amp; values"></a>keys &amp; values</h2><blockquote>
<p>这是一对基友。前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。具体请看下面的例子：</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var tfboy=&#123;<span class="string">name:</span><span class="string">'wayou'</span>,<span class="string">gender:</span><span class="string">'unknown'</span>,<span class="string">hobby:</span><span class="string">'opposite to the gender'</span>&#125;;</div><div class="line">keys(tfboy);</div><div class="line">values(tfboy);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909225910811" alt="这里写图片描述"></p>
<h2 id="monitor-amp-unmonitor"><a href="#monitor-amp-unmonitor" class="headerlink" title="monitor &amp; unmonitor"></a>monitor &amp; unmonitor</h2><blockquote>
<p>monitor(function)，它接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。而unmonitor(function)便是用来停止这一监听。</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">(name)</span></span>&#123;</div><div class="line">    alert(<span class="string">'hello,'</span>+name);</div><div class="line">&#125;</div><div class="line">monitor(sayHello);</div><div class="line">sayHello(<span class="string">'damonare'</span>);</div><div class="line">sayHello(<span class="string">'tjz'</span>);</div><div class="line">unmonitor(sayHello);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909230648805" alt="这里写图片描述"></p>
<h2 id="debug-amp-undebug"><a href="#debug-amp-undebug" class="headerlink" title="debug &amp; undebug"></a>debug &amp; undebug</h2><blockquote>
<p>debug同样也是接收一个函数名作为参数。当该函数执行时自动断下来以供调试，类似于在该函数的入口处打了个断点，可以通过debugger来做到，同时也可以通过在Chrome开发者工具里找到相应源码然后手动打断点。而undebug 则是解除该断点。而其他还有好些命令则让人没有说的欲望，因为好些都可以通过Chrome开发者工具的UI界面来操作并且比用在控制台输入要方便。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160909231322130" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><strong>本博文依据<a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#consolelogobject-object" target="_blank" rel="external">Console API文档</a>和<a href="https://developers.google.com/web/tools/chrome-devtools/debug/command-line/command-line-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#debugfunction" target="_blank" rel="external">Commond API</a>书写。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="工具" scheme="http://damonare.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Clip-Path</title>
    <link href="http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/"/>
    <id>http://damonare.github.io/2016/09/09/聊聊clip-path/</id>
    <published>2016-09-09T08:51:00.000Z</published>
    <updated>2016-09-10T10:41:03.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>图片是一个网站必不可少的元素，而呈现出绚丽多彩的图片效果在很多情况下不仅仅是设计师的工作，通过代码来修饰图片也是一个前端工程师必备的技能。因为兼容性的问题，实际项目中可能用的比较少，包括博主自己也只是用过几次剪切，很多情况下都交给设计师去做了。但作为一个hacker怎么能满足于此呢，必须深入探究！</p>
</blockquote>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Flilter"><a href="#Flilter" class="headerlink" title="Flilter"></a>Flilter</h3><blockquote>
<p>filter有十种特效来处理图片，博主只放几种特效的样例给大家看一下：</p>
<p>照片反色效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104748479" alt="照片反色"></p>
<p>照片褐色效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104803642" alt="照片褐色"></p>
<p>照片阴影效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104818298" alt="阴影"></p>
</blockquote>
<p><strong>十种特效源码:</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-webkit-<span class="attribute">filter</span>:opacity(.<span class="number">6</span>);<span class="comment">//透明度</span></div><div class="line"><span class="attribute">filter</span>:opacity(.<span class="number">6</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:blur(<span class="number">10px</span>);<span class="comment">//照片模糊</span></div><div class="line"><span class="attribute">filter</span>:blur(<span class="number">10px</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:invert(<span class="number">1</span>);</div><div class="line"><span class="attribute">filter</span>:invert(<span class="number">1</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:saturate(<span class="number">3</span>);<span class="comment">//照片饱和度</span></div><div class="line"><span class="attribute">filter</span>:saturate(<span class="number">3</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:grayscale(<span class="number">1</span>);<span class="comment">//照片灰度</span></div><div class="line"><span class="attribute">filter</span>:grayscale(<span class="number">1</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:sepia(<span class="number">1</span>);<span class="comment">//照片褐色</span></div><div class="line"><span class="attribute">filter</span>:sepia(<span class="number">1</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:hue-rotate(<span class="number">90deg</span>);<span class="comment">//色相旋转</span></div><div class="line"><span class="attribute">filter</span>:hue-rotate(<span class="number">90deg</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:brightness(.<span class="number">5</span>);<span class="comment">//亮度</span></div><div class="line"><span class="attribute">filter</span>:brightness(.<span class="number">5</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:contrast(<span class="number">2</span>);<span class="comment">//对比度</span></div><div class="line"><span class="attribute">filter</span>:contrast(<span class="number">2</span>);</div><div class="line">-webkit-<span class="attribute">filter</span>:drop-shadow(<span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">#ccc</span>);<span class="comment">//阴影</span></div><div class="line"><span class="attribute">filter</span>:drop-shadow(<span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">#ccc</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>但实际上这个属性兼容性很低：</p>
<p><img src="http://img.blog.csdn.net/20160910105340845" alt="can I use"></p>
</blockquote>
<p><strong>截止博主发文日期，Filter的兼容性如上图，我们可以看到IE是完全不支持的，Edge也是部分支持。这可能也是Filter没法用在项目中的原因之一了。感兴趣的读者可以Copy博主代码本地测试一下，或是参照<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter#blur%28%29_2" target="_blank" rel="external">MDN|Filter</a>了解。博主不在这里做过多的说明了。</strong></p>
<h3 id="clip-amp-clip-path"><a href="#clip-amp-clip-path" class="headerlink" title="clip&amp;clip-path"></a>clip&amp;clip-path</h3><blockquote>
<p>这两个属性正是今天的重头戏，博主曾在<a href="http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more">从隐藏元素谈起</a>提起过，但并没做深入解释。是的，它可以用来隐藏元素，当然也就能处理图片了。</p>
</blockquote>
<ul>
<li>clip</li>
</ul>
<blockquote>
<p>clip这个属性我相信会有很大一部分人不知道，因为这个属性使用率非常的低，因为很多情况下我们会直接重新切一张新图出来代替而不会去剪裁已有的图片，但实际上这个属性用在CSS sprite简直就如同神器一般，因为在很多情况下background-position并不符合我们的需求，比如,有时我们希望Sprite图片可以延迟滚动加载，或者是可以很轻松的右键图片另存为…或是其它background-position没法满足的情景。<br>废话不多说，看样例：<br><img src="http://img.blog.csdn.net/20160910144129604" alt="这里写图片描述"></p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">position</span>:absolute;</div><div class="line"><span class="attribute">clip</span>:rect(<span class="number">50px</span> <span class="number">250px</span> <span class="number">250px</span> <span class="number">50px</span>); <span class="comment">/* IE6, IE7 */</span></div><div class="line"><span class="attribute">clip</span>:rect(<span class="number">50px</span>,<span class="number">250px</span>,<span class="number">250px</span>,<span class="number">50px</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160910182933393" alt="这里写图片描述"></p>
<p><strong>注意，元素定位position必须是absolute或是fixed的，兼容IE6，IE7需要将值之间的逗号去掉。另外，react（top,right,bottom,left）；四个值分别是相对于图片左上角为原点的坐标值。Clip基本所有的浏览器都支持，可以放心使用。</strong></p>
<blockquote>
<p>让人放弃它的原因无外乎：</p>
<ul>
<li>clip 只对绝对定位的元素有效对于position:relative和position:static无效</li>
<li>clip 只能用于矩形，即rect()函数</li>
</ul>
</blockquote>
<ul>
<li>clip-path</li>
</ul>
<blockquote>
<p>其实clip在HTML5中已经被废弃了(依然可用)，取而代之的是clip-path。本来clip还有一个circle(圆)，但基本没有浏览器实现这个属性值，只有rect()可是使用，可能W3C也是等不下去了吧，直接推出了一个更牛逼的属性——clip-path,这个属性起初是SVG里面的然后被挪用到了CSS里面。关于SVG博主有时间会再另外介绍，这里按下不表。效果图：<br><img src="http://img.blog.csdn.net/20160910165910381" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160910165924100" alt="这里写图片描述"></p>
</blockquote>
<p><strong>读者可以在<a href="http://bennettfeely.com/clippy/" target="_blank" rel="external">这里自行体验</a></strong></p>
<blockquote>
<p>兼容：现在为止IE 和 Edge 不支持这个属性，Firefox 仅部分支持 clip-path ，<br>Chrome、Safari 和 Opera 需要使用 -webkit- 前缀支持此属性。<br><img src="http://img.blog.csdn.net/20160910172318567" alt="这里写图片描述"><br><strong>clip-path兼容性甚至比前面说到的filter还差，所以很难真正使用起来。更多使用效果<a href="http://codepen.io/wenbin5243/pen/iheHF" target="_blank" rel="external">戳这里</a>和<a href="http://species-in-pieces.com/#" target="_blank" rel="external">这里</a></strong></p>
</blockquote>
<p><strong>说一下它的四个属性值：</strong></p>
<ul>
<li>clip-source: 可以是内、外部的SVG的clipPath元素的URL引用;</li>
</ul>
<ul>
<li><p>basic-shape: 使用一些基本的形状函数创建的一个形状。主要包括circle()、ellipse()、inset()和polygon()。</p>
</li>
<li><p>geometry-box: 是可选参数。此参数和basic-shape函数一起使用时，可以为basic-shape的裁剪工作提供参考盒子。如果geometry-box由自身指定，那么它会使用指定盒子形状作为裁剪的路径，包括任何(由border-radius提供的)的角的形状。</p>
</li>
</ul>
<p><strong>开始使用clip-path</strong></p>
<blockquote>
<p>在开始使用clip-path绘制图形，或者说裁剪图形之前，有两点需要大家注意：</p>
<ul>
<li><p>使用clip-path要从同一个方向绘制，如果顺时针绘制就一律顺时针，逆时针就一律逆时针，因为polygon是一个连续线段，若线段彼此有交集，裁剪区域就会有相减的情况发生，当然如果你特意需要这样的效果除外。</p>
</li>
<li><p>如果绘制时采用比例的方式绘制，长宽就必须要先行设定，不然有可能绘制出来的长宽和我们想像的就会有差距，使用像素绘制就不会有这样的现象。</p>
</li>
</ul>
<p>我们就拿上面途中的六边形作为polygon()函数示例：</p>
</blockquote>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-webkit-<span class="keyword">clip</span>-path: polygon(<span class="number">0</span>% <span class="number">50</span>%, <span class="number">25</span>% <span class="number">0</span>%, <span class="number">75</span>% <span class="number">0</span>%, <span class="number">100</span>% <span class="number">50</span>%, <span class="number">75</span>% <span class="number">100</span>%, <span class="number">25</span>% <span class="number">100</span>%);</div><div class="line"><span class="keyword">clip</span>-path: polygon(<span class="number">0</span>% <span class="number">50</span>%, <span class="number">25</span>% <span class="number">0</span>%, <span class="number">75</span>% <span class="number">0</span>%, <span class="number">100</span>% <span class="number">50</span>%, <span class="number">75</span>% <span class="number">100</span>%, <span class="number">25</span>% <span class="number">100</span>%);</div></pre></td></tr></table></figure>
<p><strong>效果图:</strong></p>
<p><img src="http://img.blog.csdn.net/20160910174638529" alt="效果图"></p>
<p><strong>讲解：</strong></p>
<p><img src="http://img.blog.csdn.net/20160910174656822" alt="这里写图片描述"></p>
<blockquote>
<p>每个点的第一个坐标值决定了它在 x 轴上的位置，第二个坐标值指定了它在 y 轴的位置，所有点是顺时针绘制的。其实一个 polygon（）就能满足所有的形状需要了，有自定义的API用更加方便不是么。</p>
</blockquote>
<p><strong>注意：inset()这个真的坑，按说同样裁剪成方形应该是和clip的rect一样用法，可不一样！</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Clip的rect</span></div><div class="line"><span class="attribute">position</span>:absolute;</div><div class="line"><span class="attribute">clip</span>:rect(<span class="number">50px</span> <span class="number">250px</span> <span class="number">250px</span> <span class="number">50px</span>);</div><div class="line"><span class="comment">//clip-path</span></div><div class="line"><span class="attribute">clip-path</span>: inset(<span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>);</div><div class="line">-webkit-<span class="attribute">clip-path</span>: inset(<span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>);</div></pre></td></tr></table></figure>
<p><strong>本文使用图片是300*300的。</strong></p>
<blockquote>
<p>很明显：</p>
</blockquote>
 <figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cl<span class="symbol">ip:re</span>ct(<span class="number">50</span>px <span class="number">250</span>px <span class="number">250</span>px <span class="number">50</span>px);</div><div class="line">=clip-pa<span class="symbol">th:</span> inset(<span class="number">50</span>px <span class="number">50</span>px <span class="number">50</span>px <span class="number">50</span>px);</div></pre></td></tr></table></figure>
<p>好大的一个坑….</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote>
<p>相信随着时代发展，clip-path会慢慢被浏览器厂商接受的。<br>本文有任何错误，欢迎评论留言。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;图片是一个网站必不可少的元素，而呈现出绚丽多彩的图片效果在很多情况下不仅仅是设计师的工作，通过代码来修饰图片也是一个前端工程师必备的技能。因为兼容性的问题，实际项目中可能用的比较少，包括博主自己也只是用过几次剪切，很多情况下都交给设计师去做了。但作为一个hacker怎么能满足于此呢，必须深入探究！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS3" scheme="http://damonare.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>书感</title>
    <link href="http://damonare.github.io/2016/09/07/%E3%80%8A%E7%94%9F%E6%AD%BB%E7%96%B2%E5%8A%B3%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://damonare.github.io/2016/09/07/《生死疲劳》读后感/</id>
    <published>2016-09-07T14:46:12.078Z</published>
    <updated>2016-09-09T09:34:34.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>也看过不少的书，记忆中似乎也只有平凡的世界还尚可与之媲美。可今日只想独独为它写一篇日志，这本引起我诸多情感久久无法释怀的《生死疲劳》！</p>
</blockquote>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;自从莫言获奖，一直想找个机会拜读他的作品。据传莫言不论小说还是散文都给人一种如坠五里雾中的感觉普通人没法理解他想表达的意思，而仅仅读完生死疲劳就让我推翻了以前自己关于莫言的种种谬论。但不得不说的是，初读生死疲劳的确让我感觉”找不着北”……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在西门闹轮回转世蓝千岁和蓝解放的轮流叙述之下，的确让人没法分清真假对错。可当陷入莫言给读者设的一个一个有明显暗示的”陷阱”时，才知道作者那非凡的写作功力的的确确配得上诺贝尔！——即使仅仅凭借这一本书，这一本《生死疲劳》！</p>
<p>&nbsp;&nbsp;&nbsp;读过高建群的《最后一个匈奴》，在这一部高原史诗中高建群的确是吸引了读者的兴趣——通过暗示下文情节亦或是以第一人称与读者交谈。可与莫言的手法相比似乎会让他有种小巫见大巫的尴尬，可以这么说，生死疲劳给了我一种对小说全新的见解——哦！小说原来还可以这么写，这么表达！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;接下来说一下小说里很多有意思的情节，正如之前所述，整本书是运用递归的思想在运作，通过西门闹转世蓝千岁和蓝解放为我们诉说了当日西门屯大地主西门闹被冤死后在阳间六世轮回的种种往事。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;转世为驴的西门闹心中还是对这世间充满了怨恨，驴折腾并没有给我留下太深印象，也许因为作者把它放在了开头而在刚开始我并没进入作者的圈套。我只知道一向富有正义感的驴子最后死无全尸被饥民分而食之！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;成为牛后的西门闹勤勤恳恳的为主家蓝脸做事，这一部分由蓝解放叙述，所以触动最深的还是金龙和解放的兄弟之情因为革命大潮分崩离析的情节，可不能不提西门牛最终在金龙的折磨下活活被烧成重伤却自己走回了蓝脸的地界死在了主人的身边！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;西门闹转世成的西门猪又是伟大的一头猪！成猪王，历公社文革，痛哭毛主席，为猪友复仇，最后勇救落水儿童自身溺死重回地狱，似乎在这过程中身为西门闹的怨气一点点消逝……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;四世为狗的西门闹留下了诸多回忆，个人觉得故事情节在这一世才丰富多彩起来……那是一匹多么忠心可靠的狗啊！跟着解放进城担任狗协会长！回到农村紧随蓝脸直到和自己的长工一同死去！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;五世成猴，一样的忠心为主，视死如归，死去开放枪下也许是他最好的结局吧！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;六世成人，身成蓝千岁却不幸患上血友病……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;西门闹的这六世经历，作者字里行间里给我们展示了人性的悲哀，社会的黑暗，轮回的必要性。人生何尝不是如此，一个又一个的轮回游戏，活着的人死去，死去的人复生。周而复始，循环往复，无穷无尽。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;蓝解放五十几年的经历似乎让我们看到了不同的自己，沉迷于爱情的自己。从小暗恋互助，却眼看互助嫁给自己的重门弟兄金龙。不爱合作，却和她育有一子。当迈入中年又爱上了比自己小二十岁的庞春苗，可怜解放实在命途多舛，当众人肯接受这段不伦之恋时，春苗却又意外死亡。是的，命运一直在和解放开玩笑，步入老年的解放在自己儿子的撮合下和自己的初恋互助结合在了一起，也许，命中注定。至少，我觉得解放的人生过程虽然很悲剧，但结局实在很美好。祝福他们！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从没见过合作这样的女人，她也只能被莫言塑造出来吧……她没有《平凡的世界》里田晓霞的学识，没有《人生》里巧珍的死心塌地，没有《穆斯林的葬礼》里韩新月的痴情绝对，没有《白鹿原》里田小娥的放荡，没有《围城》里苏小姐的傲慢，没有《第七天》里鼠妹无私奉献的精神，也没有《活着》里家珍踏实肯干，但她就那么活生生的活在《生死疲劳》里面，我想她起初对解放是没感情的，她和她姐姐互助是双胞胎啊！同样的天生丽质！同样的美丽动人！如果……如果不是被金龙毁了名誉，她会屈身嫁给解放？！可当解放和她提出离婚时，她的无可奈何，她的坚强，就那么历历在目！让人心疼！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;蓝开放，不愧是蓝解放的种儿，跟他爹一个秉性！他对庞凤凰的爱让人吃惊，也是本人自认为本书最有看点情节之一，为了爱人拿命去赌，拿未来拿前程去赌！这的确不是一般人能做到的。他真真切切让我觉得自己跟他很像……虽然死去，起码凤凰给他留下了千岁这个后代……</p>
<p>命运齿轮从未停止转动，西门闹最终成了自己昔日长工蓝脸的重孙，我想结局是很美好的……每个人物都很生动，历经磨难终成正果，这正是我们读者所需要的文化给养。莫言，当的起中国作家第一人！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;《蛙》是莫言出版的小说中离我们最近的一部，小说写的很真实，给我们呈现了一副波澜壮阔的中国计划生育史。书中的人物似乎就在我们身边，时不时提醒警戒迂腐的人们，当想起《蛙》会有娃声在耳畔响起！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;也看过不少的书，记忆中似乎也只有平凡的世界还尚可与之媲美。可今日只想独独为它写一篇日志，这本引起我诸多情感久久无法释怀的《生死疲劳》！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="读书" scheme="http://damonare.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>无论如何，一定要对得起自己的野心</title>
    <link href="http://damonare.github.io/2016/09/07/%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AF%B9%E5%BE%97%E8%B5%B7%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8E%E5%BF%83%EF%BC%81%E2%80%94%E2%80%94%E5%85%BC%E5%BF%86%E9%AB%98%E4%B8%89/"/>
    <id>http://damonare.github.io/2016/09/07/无论如何，一定要对得起自己的野心！——兼忆高三/</id>
    <published>2016-09-07T14:43:49.078Z</published>
    <updated>2016-09-09T09:34:28.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>记忆刻满了泪痕，带着泪迹的我向青春诉说高三的往事，时间风干了写满字迹的试卷，却没有风干我们的记忆。那时候我们还在高三，那时候我们习惯在天朦胧时起床，习惯用冰凉的冷水洗漱，习惯了懒得吃早餐直奔教室，习惯了每天下午用零食对付晚饭，习惯了每节晚自习课代表催促交作业的声音。<br><a id="more"></a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可我们还是会在去食堂的道路上边走着边抱怨这可恶的教育制度并算计着高考倒计时，满脑子的睡意只想让自己在铃声响起的那一刻睡去，即使是冬天，也感觉在课堂上睡觉时温暖的，醒来之后，看着同桌在试卷上忙碌着，无奈的用冷水洗把脸，再看看课程表，数学，英语，就是没有自己喜欢的计体育课。计划在语文课上小睡一觉，计划在英语课上完成数学作业，那时候我们还在高三，喜欢在课桌上写上自己的青春誓言，喜欢在墙壁上写上自己的无奈，喜欢在铃声响起的那一刻悄然睡去，喜欢在吃饭的时候讨论每一道习题，喜欢在阳台上看望楼下走过的女生并大肆的评论一下。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;那时候我们还在高三，为了一张数学试卷我们可以熬上一个夜晚，为了一道题目我们可以忘记放学的铃声。害怕每一次考试，却又要为每次考试做准备。害怕成绩的公布，却又期待成绩的公布。假装不关心自己的成绩，心里却感到莫大的痛苦。总是对自己说，下次一定考好点，努力的汗水却一直没停止流过；那时候我们还在高三。习惯在五点半起床，习惯了三年来的中午小憩，习惯了十一点甚至更晚睡觉，习惯在漆黑的夜里开着台灯看书，习惯了被班主任被级部主任训斥，119，我们都还在，回忆亦还在，时光却已不在。<br><br>　　一转眼我们离别了高三快乐而又苦闷的日子，一切习惯变得那么不习惯，可我却又常常想起高三的日子，回想起高三的教室布局，回想起自己在学习宣言上写下的抱负，回想起一起走过黑色六月的兄弟姐妹们，回想起牵着自己牛鼻子走的任课老师们。一枚枚粉色信笺寄出了彼此的思念，彼此的牵挂。曾经我们并不相识，命运让我们在同一片屋檐下度过一生颇有意义的一年，他们说，这叫缘分。可能吧，因为它，56成了一个煽情的数字，一个永远的记号。<br>　　现在在大学里挥霍自己的青春，回想起高三的日子，却总是有种流泪的冲动，逝去的高三岁月，永远留在我们每个人的脑海里。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;苦涩的高三，曾经的老师，曾经的同学，曾经的教室，曾经的校园已渐渐远去，只留下那段美好的回忆。有时候真的好怀念，我们的集体，我的班，我真的很想你们，你们可好？<br>　　再想现在，却不免有那么些感慨，自己的两门课程，HTML，数据结构，我离自己的梦想有多远？我离他们又有多远？似乎自己没了高中的那种游刃有余，我被难住了。的确，曾经的自己是狂妄的，可现在却连一张简单的院徽图片都设计的一团糟，去学软件是不是本身也很可笑，DW，FW，PS，X5，MATLAB，我明白软件的实用性本身就在编辑者的考虑范围之内，更是因为这样，更加的看不起自己的愚笨……可面对不懂，面对知识的匮乏，我想不到还能有更好的办法去解决它，一堆堆书将我埋藏在角落，不敢说，不敢做，就那么默默的，即使四个小时一动不动，即使盯着电脑忘记了喝水，可还是一团糟，想不通是哪出了问题，新的知识充斥着大脑，难道是我的大脑内存不够了？可即使千言万语依旧不敢轻言放弃，也许，这里是我唯一可以肆意张扬的土地。<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;我要永远朝着前走，永远不要回头，或许成功和我只差那么一点，但我要说的是：坚持就是胜利。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记忆刻满了泪痕，带着泪迹的我向青春诉说高三的往事，时间风干了写满字迹的试卷，却没有风干我们的记忆。那时候我们还在高三，那时候我们习惯在天朦胧时起床，习惯用冰凉的冷水洗漱，习惯了懒得吃早餐直奔教室，习惯了每天下午用零食对付晚饭，习惯了每节晚自习课代表催促交作业的声音。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://damonare.github.io/categories/life/"/>
    
    
      <category term="Fighting" scheme="http://damonare.github.io/tags/Fighting/"/>
    
  </entry>
  
  <entry>
    <title>写在秋招之际</title>
    <link href="http://damonare.github.io/2016/09/07/%E5%86%99%E5%9C%A8%E7%A7%8B%E6%8B%9B%E4%B9%8B%E9%99%85/"/>
    <id>http://damonare.github.io/2016/09/07/写在秋招之际/</id>
    <published>2016-09-07T14:09:22.232Z</published>
    <updated>2016-09-09T09:34:23.749Z</updated>
    
    <content type="html"><![CDATA[<p><strong>人生总是会存在那么些说不清道不明的关系。</strong></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;不知不觉已经过去很长时间了好像，身边的每一个人似乎都在改变着，我说着自己不想变。却抵不住这改变的大潮浪势。有时候会想就这样吧，不要再试图改变了，也许你就是这样的人，就是这样平庸，面对赤裸裸的现实连反抗都不敢的懦夫。</p>
</blockquote>
<a id="more"></a>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><ul>
<li><h4 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h4><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果说秋招会让大四的崩溃，那么即将到来的春招就好像让我再经历一次高考一样，心里胆战心惊，毫无把握。是的，我想去杭州，不知道为啥就是想去，没有原因的想去。听蘑菇街的学长说合并之后导致HC太多，进蘑菇街的难度基本等同于阿里了。做项目，写博客，说真的，整个暑假过来也没休息过一天。唯一的原因可能就是觉得自己太菜吧。心里哈市想去阿里的，这是一定要去的，如果校招不行那就过几年通过社招，阿里是有情结在里面的，虽然深知阿里工作压力也很大，但同样，别的公司其实压力也是如此不是吗？要试一下的，今晚阿里笔试，考了很多react知识点，不知道明年还会不会考react呢，一切都是未知数啊，所以充满了不确定性。</p>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li><h4 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h4></li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;曾经我以为那个人就是我的全部，我有一个很明确的目标，就是让她过上简简单单的幸福生活。可惜到头来把自己弄的伤痕累累。人呐，真是受过伤才能长大。<strong>越是在意的东西往往越容易失去，不管你期望值放多高，来往始终是相互的，既然做不到礼尚往来，不如各自安好。</strong>感谢你在我生命中的出现让我真正看清了人性，谢谢你的离开。</p>
</blockquote>
<p><br></p>
<ul>
<li><h4 id="将来"><a href="#将来" class="headerlink" title="将来"></a>将来</h4></li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;无数次幻想过那个真正愿意和我风雨同舟的人到底是什么样子，她出现了么，或是出现了我不知道？心里还是存在一丝的希冀。可如今，似乎现实了点，不会再去想象，或许是因为曾经有一段时间我觉得自己找到了那个人吧，可现实却又一次打在了脸上，很多事不是一个人能控制的，尤其感情。自己能控制的只有自己的内心，可真正能控制自己内心的还是在少数啊……可能这就是<strong>尽人事，听天命</strong>的深层含义吧。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<mark>面对无能为力的事，也只能信命。我居然会说出这样的话，估计也是受伤太多次了。<br>那么，以后会怎样？<br>—-听天由命﻿</mark></p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>20岁，我，不服！</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;人生总是会存在那么些说不清道不明的关系。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不知不觉已经过去很长时间了好像，身边的每一个人似乎都在改变着，我说着自己不想变。却抵不住这改变的大潮浪势。有时候会想就这样吧，不要再试图改变了，也许你就是这样的人，就是这样平庸，面对赤裸裸的现实连反抗都不敢的懦夫。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Fighting" scheme="http://damonare.github.io/tags/Fighting/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目</title>
    <link href="http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>http://damonare.github.io/2016/09/07/前端面试大全（转载）/</id>
    <published>2016-09-07T14:06:38.001Z</published>
    <updated>2016-09-16T02:56:19.950Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些开放性题目"><a href="#一些开放性题目" class="headerlink" title="一些开放性题目"></a>一些开放性题目</h4><pre><code>1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。

2.项目介绍

3.如何看待前端开发？

4.平时是如何学习前端开发的？

5.未来三到五年的规划是怎样的？
</code></pre><p><br></p>
<a id="more"></a>
<h4 id="position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="position的值， relative和absolute分别是相对于谁进行定位的？"></a>position的值， relative和absolute分别是相对于谁进行定位的？</h4><ul>
<li><p><code>absolute</code> :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。</p>
</li>
<li><p><code>fixed</code> （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</p>
</li>
<li><p><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</p>
</li>
<li><p><code>static</code>  默认值。没有定位，元素出现在正常的流中</p>
</li>
<li><p><code>sticky</code> 生成粘性定位的元素，容器的位置根据正常文档流计算得出</p>
</li>
</ul>
<p><br></p>
<h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><blockquote>
<p>JSONP：</p>
</blockquote>
<p>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入。</p>
<p>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
<p><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把JSON填充到一个盒子里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">        oScript.type = <span class="string">'text/javascript'</span>;</div><div class="line">        oScript.src = sUrl;</div><div class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createJs(<span class="string">'jsonp.js'</span>);</div><div class="line"></div><div class="line">    box(&#123;</div><div class="line">       <span class="string">'name'</span>: <span class="string">'test'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">        alert(json.name);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>CORS</p>
</blockquote>
<p>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问。</p>
<blockquote>
<p>通过修改document.domain来跨子域</p>
</blockquote>
<p>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域</p>
<p>主域相同的使用<code>document.domain</code></p>
<blockquote>
<p>使用window.name来进行跨域</p>
</blockquote>
<p><code>window</code>对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</p>
<blockquote>
<p>使用HTML5中新引进的<code>window.postMessage</code>方法来跨域传送数据</p>
</blockquote>
<p>还有flash、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>
<h4 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a><code>XML</code>和<code>JSON</code>的区别？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(1).数据体积方面。</div><div class="line"></div><div class="line">JSON相对于XML来讲，数据的体积小，传递的速度更快些。</div><div class="line"></div><div class="line">(2).数据交互方面。</div><div class="line"></div><div class="line">JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</div><div class="line"></div><div class="line">(3).数据描述方面。</div><div class="line"></div><div class="line">JSON对数据的描述性比XML较差。</div><div class="line"></div><div class="line">(4).传输速度方面。</div><div class="line"></div><div class="line">JSON的速度要远远快于XML。</div></pre></td></tr></table></figure>
<h4 id="谈谈你对webpack的看法"><a href="#谈谈你对webpack的看法" class="headerlink" title="谈谈你对webpack的看法"></a>谈谈你对webpack的看法</h4><p><code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的<code>HTML、Javascript、CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p>
<p><code>webpack</code>的两大特色：</p>
<pre><code>1.code splitting（可以自动完成）

2.loader 可以处理各种类型的静态文件，并且支持串联操作
</code></pre><p><code>webpack</code> 是以<code>commonJS</code>的形式来书写脚本滴，但对 <code>AMD/CMD</code> 的支持也很全面，方便旧项目进行代码迁移。</p>
<p><code>webpack</code>具有<code>requireJs</code>和<code>browserify</code>的功能，但仍有很多自己的新特性：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 对 CommonJS 、 AMD 、ES6的语法做了兼容</div><div class="line"></div><div class="line"><span class="number">2.</span> 对js、css、图片等资源文件都支持打包</div><div class="line"></div><div class="line"><span class="number">3.</span> 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</div><div class="line"></div><div class="line"><span class="number">4.</span> 有独立的配置文件webpack.config.js</div><div class="line"></div><div class="line"><span class="number">5.</span> 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</div><div class="line"></div><div class="line"><span class="number">6.</span> 支持 SourceUrls 和 SourceMaps，易于调试</div><div class="line"></div><div class="line"><span class="number">7.</span> 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</div><div class="line"></div><div class="line"><span class="number">8.</span>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</div></pre></td></tr></table></figure>
<h4 id="说说TCP传输的三次握手四次挥手策略"><a href="#说说TCP传输的三次握手四次挥手策略" class="headerlink" title="说说TCP传输的三次握手四次挥手策略"></a>说说TCP传输的三次握手四次挥手策略</h4><p> 为了准确无误地把数据送达目标处，<code>TCP</code>协议采用了三次握手策略。用TCP协议把数据包送出去后，<code>TCP</code>不会对传送    后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：<code>SYN</code>和<code>ACK</code>。</p>
<p>发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。<br>最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，<code>TCP</code>协议会再次以相同的顺序发送相同的数据包。</p>
<p><br></p>
<blockquote>
<p>断开一个TCP连接则需要“四次握手”：</p>
</blockquote>
<ul>
<li><p>第一次挥手：主动关闭方发送一个<code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
</li>
<li><p>第二次挥手：被动关闭方收到<code>FIN</code>包后，发送一个<code>ACK</code>给对方，确认序号为收到序号<code>+1</code>（与<code>SYN</code>相同，一个<code>FIN</code>占用一个序号）。</p>
</li>
<li><p>第三次挥手：被动关闭方发送一个<code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
</li>
<li><p>第四次挥手：主动关闭方收到<code>FIN</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
</li>
</ul>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<code>TCP</code>连接必须要经过三次“对话”才能建立起来</p>
<p><code>UDP</code>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h4 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h4><p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的。</p>
<h4 id="创建ajax过程"><a href="#创建ajax过程" class="headerlink" title="创建ajax过程"></a>创建ajax过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</div><div class="line"></div><div class="line">(<span class="number">2</span>)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</div><div class="line"></div><div class="line">(<span class="number">3</span>)设置响应HTTP请求状态变化的函数.</div><div class="line"></div><div class="line">(<span class="number">4</span>)发送HTTP请求.</div><div class="line"></div><div class="line">(<span class="number">5</span>)获取异步调用返回的数据.</div><div class="line"></div><div class="line">(<span class="number">6</span>)使用JavaScript和DOM实现局部刷新.</div></pre></td></tr></table></figure>
<h4 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h4><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<h4 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" class="headerlink" title="常见web安全及防护原理"></a>常见web安全及防护原理</h4><blockquote>
<p>sql注入原理</p>
</blockquote>
<p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>总的来说有以下几点：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1.</span>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<span class="string">"-"</span>进行转换等。</div><div class="line"></div><div class="line"><span class="number">2.</span>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</div><div class="line"></div><div class="line"><span class="number">3.</span>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</div><div class="line"></div><div class="line"><span class="number">4.</span>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</div></pre></td></tr></table></figure>
<blockquote>
<p>XSS原理及防范</p>
</blockquote>
<p>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 <code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个</p>
<p>看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，</p>
<p>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p>
<blockquote>
<p>XSS防范方法</p>
</blockquote>
<p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code> 攻击。</p>
<p>首先，避免直接在<code>cookie</code> 中泄露用户隐私，例如email、密码等等。</p>
<p>其次，通过使<code>cookie</code> 和系统<code>ip</code> 绑定来降低<code>cookie</code> 泄露后的危险。这样攻击者得到的<code>cookie</code> 没有实际价值，不可能拿来重放。</p>
<p>如果网站不需要再浏览器端对<code>cookie</code> 进行操作，可以在<code>Set-Cookie</code> 末尾加上<code>HttpOnly</code> 来防止<code>javascript</code> 代码直接获取<code>cookie</code> 。</p>
<p>尽量采用<code>POST</code> 而非<code>GET</code> 提交表单</p>
<blockquote>
<p>XSS与CSRF有什么区别吗？</p>
</blockquote>
<p><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p>
<p>要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">登录受信任网站<span class="keyword">A</span>，并在本地生成Cookie。</div><div class="line"></div><div class="line">在不登出<span class="keyword">A</span>的情况下，访问危险网站B。</div></pre></td></tr></table></figure>
<blockquote>
<p>CSRF的防御</p>
</blockquote>
<ul>
<li><p>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p>
</li>
<li><p>通过验证码的方法</p>
</li>
</ul>
<h4 id="Web-Worker-和webSocket"><a href="#Web-Worker-和webSocket" class="headerlink" title="Web Worker 和webSocket"></a>Web Worker 和webSocket</h4><blockquote>
<p>worker主线程:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>通过 worker = <span class="keyword">new</span> Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。</div><div class="line"></div><div class="line"><span class="number">2.</span>通过worker.postMessage( data ) 方法来向worker发送数据。</div><div class="line"></div><div class="line"><span class="number">3.</span>绑定worker.onmessage方法来接收worker发送过来的数据。</div><div class="line"></div><div class="line"><span class="number">4.</span>可以使用 worker.terminate() 来终止一个worker的执行。</div></pre></td></tr></table></figure>
<p><code>WebSocket</code>是<code>Web</code>应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个<code>HTML5</code>协议，<code>WebSocket</code>的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p><code>HTTP</code>协议通常承载于TCP协议之上，在<code>HTTP</code>和<code>TCP</code>之间添加一个安全协议层（<code>SSL</code>或<code>TSL</code>），这个时候，就成了我们常说的HTTPS。</p>
<p>默认HTTP的端口号为80，<code>HTTPS</code>的端口号为443。</p>
<h4 id="为什么HTTPS安全"><a href="#为什么HTTPS安全" class="headerlink" title="为什么HTTPS安全"></a>为什么<code>HTTPS</code>安全</h4><p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用<code>HTTPS</code>，密钥在你和终点站才有。<code>https</code>之所以比<code>http</code>安全，是因为他利用<code>ssl/tls</code>协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p>
<h4 id="对前端模块化的认识"><a href="#对前端模块化的认识" class="headerlink" title="对前端模块化的认识"></a>对前端模块化的认识</h4><blockquote>
<p>AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。</p>
<p>CMD 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p><code>AMD</code> 是提前执行，<code>CMD</code> 是延迟执行。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<blockquote>
<p>CMD模块方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 模块代码</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Javascript垃圾回收方法"><a href="#Javascript垃圾回收方法" class="headerlink" title="Javascript垃圾回收方法"></a>Javascript垃圾回收方法</h4><blockquote>
<p>标记清除（mark and sweep）</p>
</blockquote>
<p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>
<blockquote>
<p>引用计数(reference counting)</p>
</blockquote>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>
<p>在IE中虽然<code>JavaScript</code>对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，<br>也就是说只要涉及<code>BOM</code>及DOM就会出现循环引用问题。</p>
<h4 id="你觉得前端工程的价值体现在哪"><a href="#你觉得前端工程的价值体现在哪" class="headerlink" title="你觉得前端工程的价值体现在哪"></a>你觉得前端工程的价值体现在哪</h4><pre><code>为简化用户使用提供技术支持（交互部分）

为多个浏览器兼容性提供支持

为提高用户浏览速度（浏览器性能）提供支持

为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持

为展示数据提供支持（数据接口）
</code></pre><h4 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h4><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。</p>
<p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p>
<p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</p>
<p>请求带宽：压缩文件，开启GZIP，</p>
<blockquote>
<p>代码层面的优化</p>
</blockquote>
<ul>
<li><p>用<code>hash-table</code>来优化查找</p>
</li>
<li><p>少用全局变量</p>
</li>
<li><p>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</p>
</li>
<li><p>用<code>setTimeout</code>来避免页面失去响应</p>
</li>
<li><p>缓存DOM节点查找的结果</p>
</li>
<li><p>避免使用CSS Expression</p>
</li>
<li><p>避免全局查询</p>
</li>
<li><p>避免使用with(with会创建自己的作用域，会增加作用域链长度)</p>
</li>
<li><p>多个变量声明合并</p>
</li>
<li><p>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</p>
</li>
<li>尽量避免写在HTML标签中写Style属性</li>
</ul>
<h4 id="移动端性能优化"><a href="#移动端性能优化" class="headerlink" title="移动端性能优化"></a>移动端性能优化</h4><ul>
<li>尽量使用css3动画，开启硬件加速。</li>
<li>适当使用<code>touch</code>事件代替<code>click</code>事件。</li>
<li>避免使用<code>css3</code>渐变阴影效果。</li>
<li>可以用<code>transform: translateZ(0)</code>来开启硬件加速。</li>
<li>不滥用Float。Float在渲染时计算量比较大，尽量减少使用</li>
<li>不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。</li>
<li>合理使用requestAnimationFrame动画代替setTimeout</li>
<li>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加</li>
<li>PC端的在移动端同样适用</li>
</ul>
<blockquote>
<p>相关阅读：<a href="https://github.com/cssmagic/blog/issues/20" target="_blank" rel="external">如何做到一秒渲染一个移动页面</a></p>
</blockquote>
<h4 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h4><p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。<br></p>
<p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到  <code>200 OK</code>(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p>
<p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和<code>Etag</code></p>
<p>然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据<code>Etag</code>，判断文件内容自上一次请求之后，有没有发生变化</p>
<p>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发<code>index.html</code>的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— <code>304 Not Modified</code>，此时浏览器就会从本地缓存中获取<code>index.html</code>的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。<br></p>
<p>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</p>
<p><br></p>
<p>① 只有get请求会被缓存，post请求不会</p>
<h4 id="Expires和Cache-Control"><a href="#Expires和Cache-Control" class="headerlink" title="Expires和Cache-Control"></a>Expires和Cache-Control</h4><p><code>Expires</code>要求客户端和服务端的时钟严格同步。<code>HTTP1.1</code>引入<code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Cache-Control: no-cache, private, max-age=<span class="number">0</span></div><div class="line"></div><div class="line">ETag: abcde</div><div class="line"></div><div class="line">Expires: Thu, <span class="number">15</span> Apr <span class="number">2014</span> <span class="number">20</span>:<span class="number">00</span>:<span class="number">00</span> GMT</div><div class="line"></div><div class="line">Pragma: private</div><div class="line"></div><div class="line">Last-Modified: $now <span class="comment">// RFC1123 format</span></div></pre></td></tr></table></figure>
<h4 id="ETag应用"><a href="#ETag应用" class="headerlink" title="ETag应用:"></a>ETag应用:</h4><p><code>Etag</code>由服务器端生成，客户端通过<code>If-Match</code>或者说<code>If-None-Match</code>这个条件判断请求来验证资源是否修改。常见的是使用<code>If-None-Match</code>。请求一个文件的流程可能如下：</p>
<p>====第一次请求===</p>
<pre><code>1.客户端发起 HTTP GET 请求一个文件；

2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200
</code></pre><p>====第二次请求===</p>
<pre><code>客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办
</code></pre><p>答案是同时使用，也就是说在完全匹配<code>If-Modified-Since</code>和<code>If-None-Match</code>即检查完修改时间和<code>Etag</code>之后，</p>
<p>服务器才能返回304.(不要陷入到底使用谁的问题怪圈)</p>
<p>为什么使用Etag请求头?</p>
<p>Etag 主要为了解决 <code>Last-Modified</code> 无法解决的一些问题。</p>
<h4 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h4><pre><code>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除
</code></pre><h4 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h4><pre><code>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。

堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。
</code></pre><h4 id="快速-排序的思想并实现一个快排？"><a href="#快速-排序的思想并实现一个快排？" class="headerlink" title="快速 排序的思想并实现一个快排？"></a>快速 排序的思想并实现一个快排？</h4><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>
<p>　　（1）在数据集之中，找一个基准点</p>
<p>　　（2）建立两个数组，分别存储左边和右边的数组</p>
<p>　　（3）利用递归进行下次比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> arr;<span class="comment">//如果数组只有一个数，就直接返回；</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//找到中间数的索引值，如果是浮点数，则向下取整</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> numValue = arr.splice(num,<span class="number">1</span>);<span class="comment">//找到中间数的值</span></div><div class="line">        <span class="keyword">var</span> left = [];</div><div class="line">        <span class="keyword">var</span> right = [];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i]&lt;numValue)&#123;</div><div class="line">                left.push(arr[i]);<span class="comment">//基准点的左边的数传到左边数组</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">               right.push(arr[i]);<span class="comment">//基准点的右边的数传到右边数组</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> quickSort(left).concat([numValue],quickSort(right));<span class="comment">//递归不断重复比较</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    alert(quickSort([<span class="number">32</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">87</span>]));<span class="comment">//弹出“2,16,32,37,45,87”</span></div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<h4 id="你觉得jQuery或zepto源码有哪些写的好的地方"><a href="#你觉得jQuery或zepto源码有哪些写的好的地方" class="headerlink" title="你觉得jQuery或zepto源码有哪些写的好的地方"></a>你觉得jQuery或zepto源码有哪些写的好的地方</h4><p>(答案仅供参考)</p>
<p><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当<code>jquery</code>中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问<code>window</code>对象。同样，传入<code>undefined</code>参数，可以缩短查找undefined时的作用域链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line"></div><div class="line">     <span class="comment">//用一个函数域包起来，就是所谓的沙箱</span></div><div class="line"></div><div class="line">     <span class="comment">//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span></div><div class="line"></div><div class="line">     <span class="comment">//把当前沙箱需要的外部变量通过函数参数引入进来</span></div><div class="line"></div><div class="line">     <span class="comment">//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span></div><div class="line"></div><div class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line"></div><div class="line">&#125;)( <span class="built_in">window</span> );</div></pre></td></tr></table></figure>
<p>jquery将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法。</p>
<p>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。</p>
<p><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p>
<h4 id="ES6的了解"><a href="#ES6的了解" class="headerlink" title="ES6的了解"></a>ES6的了解</h4><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值<code>Inputs=&gt;outputs</code>。）、<code>for-of</code>（用来遍历数据—例如数组中的值。）<code>arguments</code>对象可被不定参数和默认参数完美代替。<code>ES6</code>将<code>promise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。增加了<code>let</code>和<code>const</code>命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，<code>var</code>命令和<code>function</code>命令声明的全局变量，属于全局对象的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于全局对象的属性。。还有就是引入<code>module</code>模块的概念</p>
<h4 id="js继承方式及其优缺点"><a href="#js继承方式及其优缺点" class="headerlink" title="js继承方式及其优缺点"></a>js继承方式及其优缺点</h4><blockquote>
<p>原型链继承的缺点</p>
</blockquote>
<pre><code>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
</code></pre><blockquote>
<p>借用构造函数（类式继承）</p>
</blockquote>
<pre><code>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承
</code></pre><blockquote>
<p>组合式继承</p>
</blockquote>
<pre><code>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
</code></pre><p>具体请看：<a href="http://segmentfault.com/a/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
<h4 id="关于Http-2-0-你知道多少？"><a href="#关于Http-2-0-你知道多少？" class="headerlink" title="关于Http 2.0 你知道多少？"></a>关于Http 2.0 你知道多少？</h4><p><code>HTTP/2</code>引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p>
<p><code>HTTP/2</code>提供更多的加密支持</p>
<p><code>HTTP/2</code>使用多路技术，允许多个消息在一个连接上同时交差。</p>
<p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的<code>header</code>都只会占用很小比例的带宽。</p>
<p><br></p>
<h4 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h4><blockquote>
<p>defer并行加载js文件，会按照页面上script标签的顺序执行<br>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p>
</blockquote>
<h4 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动"></a>谈谈浮动和清除浮动</h4><p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p>
<h4 id="如何评价AngularJS和BackboneJS"><a href="#如何评价AngularJS和BackboneJS" class="headerlink" title="如何评价AngularJS和BackboneJS"></a>如何评价AngularJS和BackboneJS</h4><p><code>backbone</code>具有依赖性，依赖<code>underscore.js</code>。<code>Backbone + Underscore + jQuery(or Zepto)</code> 就比一个<code>AngularJS</code> 多出了2 次HTTP请求.</p>
<p><br></p>
<p><code>Backbone</code>的<code>Model</code>没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。<code>AngularJS</code>与此相反，Model直接与UI视图绑定，<code>Model</code>与UI视图的关系，通过<code>directive</code>封装，<code>AngularJS</code>内置的通用<code>directive</code>，就能实现大部分操作了，也就是说，基本不必关心<code>Model</code>与UI视图的关系，直接操作Model就行了，UI视图自动更新。</p>
<p><br></p>
<p><code>AngularJS</code>的<code>directive</code>，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。</p>
<h4 id="用过哪些设计模式？"><a href="#用过哪些设计模式？" class="headerlink" title="用过哪些设计模式？"></a>用过哪些设计模式？</h4><blockquote>
<p>工厂模式：</p>
</blockquote>
<pre><code>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。

    工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。


function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.profession = profession;
    obj.move = function () {
        return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession;
    };
    return obj;
}
var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例
</code></pre><p><br></p>
<blockquote>
<p>构造函数模式</p>
</blockquote>
<p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：</p>
<pre><code>1.构造函数方法没有显示的创建对象 (new Object());

2.直接将属性和方法赋值给 this 对象;

3.没有 renturn 语句。
</code></pre><h4 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h4><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
<p>闭包有三个特性：</p>
<blockquote>
<p>1.函数嵌套函数</p>
<p>2.函数内部可以引用外部的参数和变量</p>
<p>3.参数和变量不会被垃圾回收机制回收</p>
</blockquote>
<p> 具体请看：<a href="http://segmentfault.com/a/1190000000652891" target="_blank" rel="external">详解js闭包</a></p>
<h4 id="请你谈谈Cookie的弊端"><a href="#请你谈谈Cookie的弊端" class="headerlink" title="请你谈谈Cookie的弊端"></a>请你谈谈Cookie的弊端</h4><p><code>cookie</code>虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p>
<p>第一：每个特定的域名下最多生成20个<code>cookie</code></p>
<pre><code>1.IE6或更低版本最多20个cookie

2.IE7和之后的版本最后可以有50个cookie。

3.Firefox最多50个cookie

4.chrome和Safari没有做硬性限制
</code></pre><p><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</p>
<p><code>cookie</code>的最大大约为<code>4096</code>字节，为了兼容性，一般不能超过<code>4095</code>字节。</p>
<p>IE 提供了一种存储可以持久化用户数据，叫做<code>userdata</code>，从<code>IE5.0</code>就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<blockquote>
<p>优点：极高的扩展性和可用性</p>
</blockquote>
<pre><code>1.通过良好的编程，控制保存在cookie中的session对象的大小。

2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。

3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。

4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
</code></pre><blockquote>
<p>缺点：</p>
</blockquote>
<pre><code>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.


2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</code></pre><h4 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h4><p>在较高版本的浏览器中，<code>js</code>提供了<code>sessionStorage</code>和<code>globalStorage</code>。在<code>HTML5</code>中提供了<code>localStorage</code>来取代<code>globalStorage</code>。</p>
<p><code>html5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。</p>
<p><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h4 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h4><p><code>Web Storage</code>的概念和<code>cookie</code>相似，区别是它是为了更大容量存储设计的。<code>Cookie</code>的大小是受限的，并且每次你请求一个新的页面的时候<code>Cookie</code>都会被发送过去，这样无形中浪费了带宽，另外<code>cookie</code>还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，<code>Web Storage</code>拥有<code>setItem,getItem,removeItem,clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie，getCookie</code>。</p>
<p>但是<code>cookie</code>也是不可以或缺的：<code>cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生</p>
<p>浏览器的支持除了<code>IE７</code>及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的<code>userData</code>其实就是<code>javascript</code>本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持<code>web storage</code>。</p>
<p><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，例如<code>setItem、getItem</code>和<code>removeItem</code>等</p>
<h4 id="cookie-和session-的区别："><a href="#cookie-和session-的区别：" class="headerlink" title="cookie 和session 的区别："></a>cookie 和session 的区别：</h4><pre><code>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗

   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能

    考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：

   将登陆信息等重要信息存放为SESSION

   其他信息如果需要保留，可以放在COOKIE中
</code></pre><blockquote>
<p><code>display:none</code>和<code>visibility:hidden</code>的区别？</p>
</blockquote>
<pre><code>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。

visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。
</code></pre><blockquote>
<p>CSS中<code>link</code> 和<code>@import</code>的区别是？</p>
</blockquote>
<pre><code>(1) link属于HTML标签，而@import是CSS提供的;

(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;

(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;

(4) link方式的样式的权重 高于@import的权重.
</code></pre><blockquote>
<p><code>position:absolute</code>和<code>float</code>属性的异同</p>
</blockquote>
<ul>
<li>共同点：对内联元素设置<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高。</li>
</ul>
<ul>
<li>不同点：<code>float</code>仍会占据位置，<code>absolute</code>会覆盖文档流中的其他元素。</li>
</ul>
<blockquote>
<p>介绍一下box-sizing属性？</p>
</blockquote>
<p><code>box-sizing</code>属性主要用来控制元素的盒模型的解析模式。默认值是<code>content-box</code>。</p>
<ul>
<li><p><code>content-box</code>：让元素维持W3C的标准盒模型。元素的宽度/高度由<code>border + padding + content</code>的宽度/高度决定，设置<code>width/height</code>属性指的是<code>content</code>部分的宽/高</p>
</li>
<li><p><code>border-box</code>：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置<code>width/height</code>属性指的是<code>border + padding + content</code></p>
</li>
</ul>
<p>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</p>
<blockquote>
<p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1<span class="selector-class">.id</span>选择器（ # <span class="selector-tag">myid</span>）</div><div class="line"></div><div class="line">2.类选择器（<span class="selector-class">.myclassname</span>）</div><div class="line"></div><div class="line">3.标签选择器（<span class="selector-tag">div</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">p</span>）</div><div class="line"></div><div class="line">4.相邻选择器（<span class="selector-tag">h1</span> + <span class="selector-tag">p</span>）</div><div class="line"></div><div class="line">5.子选择器（<span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span>）</div><div class="line"></div><div class="line">6.后代选择器（<span class="selector-tag">li</span> <span class="selector-tag">a</span>）</div><div class="line"></div><div class="line">7.通配符选择器（ * ）</div><div class="line"></div><div class="line">8.属性选择器（<span class="selector-tag">a</span><span class="selector-attr">[rel = "external"]</span>）</div><div class="line"></div><div class="line">9.伪类选择器（<span class="selector-tag">a</span>: <span class="selector-tag">hover</span>, <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>）</div></pre></td></tr></table></figure>
<p><strong>优先级为:</strong></p>
<p><code>!important &gt;  id &gt; class &gt; tag</code></p>
<p><code>important</code> 比 内联优先级高,但内联比 <code>id</code> 要高</p>
<blockquote>
<p>CSS3新增伪类举例：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-of-type</span> 选择属于其父元素的首个 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span>  选择属于其父元素的最后 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-of-type</span>  选择属于其父元素唯一的 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-child</span>    选择属于其父元素的唯一子元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span>  选择属于其父元素的第二个子元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-pseudo">:enabled</span>  <span class="selector-pseudo">:disabled</span> 控制表单控件的禁用状态。</div><div class="line"></div><div class="line"><span class="selector-pseudo">:checked</span>        单选框或复选框被选中。</div></pre></td></tr></table></figure>
<blockquote>
<p>CSS3有哪些新特性？</p>
</blockquote>
<pre><code>CSS3实现圆角（border-radius），阴影（box-shadow），

对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）

transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜

增加了更多的CSS选择器  多背景 rgba

在CSS3中唯一引入的伪元素是::selection.

媒体查询，多栏布局

border-image
</code></pre><p>CSS3中新增了一种盒模型计算方式：<code>box-sizing</code>。盒模型默认的值是<code>content-box</code>, 新增的值是<code>padding-box</code>和<code>border-box</code>，几种盒模型计算元素宽高的区别如下：</p>
<h4 id="content-box（默认）"><a href="#content-box（默认）" class="headerlink" title="content-box（默认）"></a><code>content-box（默认）</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure>
<h4 id="padding-box"><a href="#padding-box" class="headerlink" title="padding-box"></a><code>padding-box</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure>
<h4 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a><code>border-box</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure>
<blockquote>
<p>对BFC规范的理解？</p>
</blockquote>
<pre><code>  BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。

（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。
</code></pre><h4 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h4><pre><code>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构

2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；

4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
</code></pre><h4 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h4><p>1）、<code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</p>
<p>2）、严格模式的排版和 <code>JS</code> 运作模式是  以该浏览器支持的最高标准运行。</p>
<p>3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>
<p>4）、<code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现。</p>
<h4 id="你知道多少种Doctype文档类型？"><a href="#你知道多少种Doctype文档类型？" class="headerlink" title="你知道多少种Doctype文档类型？"></a>你知道多少种<code>Doctype</code>文档类型？</h4><pre><code> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。

 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。

 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。

Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks

 （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。
</code></pre><h4 id="HTML与XHTML——二者有什么区别"><a href="#HTML与XHTML——二者有什么区别" class="headerlink" title="HTML与XHTML——二者有什么区别"></a>HTML与XHTML——二者有什么区别</h4><pre><code>区别：

1.所有的标记都必须要有一个相应的结束标记

2.所有标签的元素和属性的名字都必须使用小写

3.所有的XML标记都必须合理嵌套

4.所有的属性必须用引号&quot;&quot;括起来

5.把所有&lt;和&amp;特殊符号用编码表示

6.给所有属性赋一个值

7.不要在注释内容中使“--”

8.图片必须有说明文字
</code></pre><h4 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h4><pre><code>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.

浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）

#box{ float:left; width:10px; margin:0 0 0 100px;}

这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入
_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

渐进识别的方式，从总体中逐渐排除局部。


  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。

  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

  css

      .bb{

       background-color:#f1ee18;/*所有识别*/

      .background-color:#00deff\9; /*IE6、7、8识别*/

      +background-color:#a200ff;/*IE6、7识别*/

      _background-color:#1e0bd1;/*IE6识别*/

      }


怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发
怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在
可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;`
</code></pre><blockquote>
<p>上下margin重合问题</p>
</blockquote>
<pre><code>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。

解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。
</code></pre><h4 id="解释下浮动和它的工作原理？清除浮动的技巧"><a href="#解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的技巧"></a>解释下浮动和它的工作原理？清除浮动的技巧</h4><pre><code>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。


1.使用空标签清除浮动。

   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。

2.使用overflow。

   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。

3.使用after伪对象清除浮动。

   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；
</code></pre><h4 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h4><pre><code>浮动元素引起的问题：

（1）父元素的高度无法被撑开，影响与父元素同级的元素

（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后

（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
</code></pre><blockquote>
<p>解决方法：</p>
</blockquote>
<p>使用<code>CSS</code>中的<code>clear:both</code>;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>: <span class="string">"."</span>;<span class="attribute">display</span>: block;<span class="attribute">height</span>: <span class="number">0</span>;<span class="attribute">clear</span>: both;<span class="attribute">visibility</span>: hidden;&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.clearfix</span>&#123;<span class="attribute">display</span>: inline-block;&#125; <span class="comment">/* for IE/Mac */</span></div></pre></td></tr></table></figure>
<p><strong>清除浮动的几种方法：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1，额外标签法，&lt;div style="clear:both;"&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</div><div class="line"></div><div class="line">2，使用after伪类</div><div class="line"></div><div class="line">#parent:after&#123;</div><div class="line"></div><div class="line">    content:".";</div><div class="line"></div><div class="line">    height:0;</div><div class="line"></div><div class="line">    visibility:hidden;</div><div class="line"></div><div class="line">    display:block;</div><div class="line"></div><div class="line">    clear:both;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">3,浮动外部元素</div><div class="line"></div><div class="line">4,设置overflow为hidden或者auto</div></pre></td></tr></table></figure>
<h4 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h4><blockquote>
<p>1）创建新节点</p>
</blockquote>
<pre><code>createDocumentFragment()    //创建一个DOM片段

createElement()   //创建一个具体的元素

createTextNode()   //创建一个文本节点
</code></pre><blockquote>
<p>2）添加、移除、替换、插入</p>
</blockquote>
<pre><code>appendChild()

removeChild()

replaceChild()

insertBefore() //并没有insertAfter()
</code></pre><blockquote>
<p>3）查找</p>
</blockquote>
<pre><code>getElementsByTagName()    //通过标签名称

getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，
会得到一个数组，其中包括id等于name值的)

getElementById()    //通过元素Id，唯一性
</code></pre><h4 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h4><pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

拖拽释放(Drag and drop) API

语义化更好的内容标签（header,nav,footer,aside,article,section）

音频、视频API(audio,video)

画布(Canvas) API

地理(Geolocation) API

本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；

sessionStorage 的数据在浏览器关闭后自动删除


表单控件，calendar、date、time、email、url、search

新的技术webworker, websocket, Geolocation
</code></pre><blockquote>
<p>移除的元素</p>
</blockquote>
<pre><code>纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；
</code></pre><blockquote>
<p>支持HTML5新标签：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IE8/IE7/IE6支持通过document.createElement方法产生的标签，</div><div class="line"></div><div class="line">可以利用这一特性让这些浏览器支持HTML5新标签，</div><div class="line"></div><div class="line">当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</div><div class="line"></div><div class="line">   <span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line"></div><div class="line">   &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;</div><div class="line"></div><div class="line">   &lt;![endif]--&gt;</div><div class="line"></div><div class="line">如何区分： DOCTYPE声明\新增的结构元素\功能元素</div></pre></td></tr></table></figure>
<h4 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">调用localstorge、cookies等本地存储方式</div></pre></td></tr></table></figure>
<h4 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> FOUC - Flash Of Unstyled Content 文档样式闪烁</div><div class="line"></div><div class="line"> <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span>&gt;</span><span class="css">@<span class="keyword">import</span> <span class="string">"../fouc.css"</span>;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line">而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</div><div class="line"></div><div class="line"> 解决方法简单的出奇，只要在<span class="tag">&lt;<span class="name">head</span>&gt;</span>之间加入一个<span class="tag">&lt;<span class="name">link</span>&gt;</span>或者<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">元素就可以了。</span></div></pre></td></tr></table></figure>
<h4 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h4><p><code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>。</p>
<p>当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。</p>
<p><code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<pre><code>（1）变量被声明了，但没有赋值时，就等于undefined。


（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。


（3）对象没有赋值的属性，该属性的值为undefined。


（4）函数没有返回值时，默认返回undefined。
</code></pre><p><code>null</code>表示”没有对象”，即该处不应该有值。典型用法是：</p>
<pre><code>（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。
</code></pre><h4 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h4><pre><code>   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。

   2、属性和方法被加入到 this 引用的对象中。

   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。



var obj  = {};

obj.__proto__ = Base.prototype;

Base.call(obj);
</code></pre><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><pre><code>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js
</code></pre><h4 id="call-和-apply-的区别和作用？"><a href="#call-和-apply-的区别和作用？" class="headerlink" title="call() 和 apply() 的区别和作用？"></a><code>call()</code> 和 <code>apply()</code> 的区别和作用？</h4><p>作用：动态改变某个类的某个方法的运行环境（执行上下文）。</p>
<p>区别参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader15" target="_blank" rel="external">JavaScript学习总结（四）function函数部分</a></p>
<h4 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h4><pre><code>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。



setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。

闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
</code></pre><p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000687844" target="_blank" rel="external">详解js变量、作用域及内存</a></p>
<h4 id="列举IE-与其他浏览器不一样的特性？"><a href="#列举IE-与其他浏览器不一样的特性？" class="headerlink" title="列举IE 与其他浏览器不一样的特性？"></a>列举IE 与其他浏览器不一样的特性？</h4><ul>
<li><p>IE支持<code>currentStyle</code>，FIrefox使用<code>getComputStyle</code></p>
</li>
<li><p>IE  使用<code>innerText</code>，Firefox使用<code>textContent</code></p>
</li>
<li><p>滤镜方面：IE:<code>filter:alpha(opacity= num)</code>；Firefox：<code>-moz-opacity:num</code></p>
</li>
<li><p>事件方面：IE：<code>attachEvent</code>：火狐是<code>addEventListener</code></p>
</li>
<li><p>鼠标位置：IE是<code>event.clientX</code>；火狐是<code>event.pageX</code></p>
</li>
<li><p>IE使用<code>event.srcElement</code>；Firefox使用<code>event.target</code></p>
</li>
<li><p>IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置<code>margin:0;padding:0以及list-style:none</code></p>
</li>
<li><p>CSS圆角：ie7以下不支持圆角</p>
</li>
</ul>
<h4 id="WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h4><p>Javascript数据推送</p>
<ul>
<li><code>Commet</code>：基于HTTP长连接的服务器推送技术</li>
</ul>
<ul>
<li>基于<code>WebSocket</code>的推送方案</li>
</ul>
<ul>
<li><code>SSE</code>（Server-Send Event）：服务器推送数据新方式</li>
</ul>
<h4 id="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h4><pre><code>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。

    1、实现界面交互

    2、提升用户体验

    3、有了Node.js，前端可以实现服务端的一些事情


前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，



 参与项目，快速高质量完成实现效果图，精确到1px；

 与团队成员，UI设计，产品经理的沟通；

 做好的页面结构，页面重构和用户体验；

 处理hack，兼容、写出优美的代码格式；

 针对服务器的优化、拥抱最新前端技术。
</code></pre><h4 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h4><pre><code>    分为4个步骤：

    （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。

    （2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

    （3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。

    （4），此时，`Web`服务器提供资源服务，客户端开始下载资源。



请求返回后，便进入了我们关注的前端模块

简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM`
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000697254" target="_blank" rel="external">从输入 URL 到浏览器接收的过程中发生了什么事情？</a></p>
<h4 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a>javascript对象的几种创建方式</h4><pre><code>1，工厂模式

2，构造函数模式

3，原型模式

4，混合构造函数和原型模式

5，动态原型模式

6，寄生构造函数模式

7，稳妥构造函数模式
</code></pre><h4 id="javascript继承的6种方法"><a href="#javascript继承的6种方法" class="headerlink" title="javascript继承的6种方法"></a>javascript继承的6种方法</h4><pre><code>1，原型链继承

2，借用构造函数继承

3，组合继承(原型+借用构造)

4，原型式继承

5，寄生式继承

6，寄生组合式继承
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
<h4 id="创建ajax的过程"><a href="#创建ajax的过程" class="headerlink" title="创建ajax的过程"></a>创建ajax的过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)创建<span class="string">`XMLHttpRequest`</span>对象,也就是创建一个异步调用对象.</div><div class="line"></div><div class="line">(<span class="number">2</span>)创建一个新的<span class="string">`HTTP`</span>请求,并指定该<span class="string">`HTTP`</span>请求的方法、<span class="string">`URL`</span>及验证信息.</div><div class="line"></div><div class="line">(<span class="number">3</span>)设置响应<span class="string">`HTTP`</span>请求状态变化的函数.</div><div class="line"></div><div class="line">(<span class="number">4</span>)发送<span class="string">`HTTP`</span>请求.</div><div class="line"></div><div class="line">(<span class="number">5</span>)获取异步调用返回的数据.</div><div class="line"></div><div class="line">(<span class="number">6</span>)使用JavaScript和DOM实现局部刷新.</div><div class="line"></div><div class="line"></div><div class="line">var xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">xmlHttp.open(<span class="string">'GET'</span>,<span class="string">'demo.php'</span>,<span class="string">'true'</span>);</div><div class="line"></div><div class="line">xmlHttp.send()</div><div class="line"></div><div class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp; xmlHttp.status === <span class="number">200</span>)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<h4 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h4><pre><code>1.异步加载的方案： 动态插入script标签

2.通过ajax去获取js代码，然后通过eval执行

3.script标签上添加defer或者async属性

4.创建并插入iframe，让它异步执行js

5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。
</code></pre><h4 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h4><pre><code>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个
Firefox，chrome也是6个
</code></pre><p>####<code>Flash</code>、<code>Ajax</code>各自的优缺点，在使用中如何取舍？</p>
<ul>
<li><code>Flash</code>适合处理多媒体、矢量图形、访问机器；对<code>CSS</code>、处理文本上不足，不容易被搜索。</li>
</ul>
<p>-<code>Ajax</code>对<code>CSS</code>、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</p>
<ul>
<li>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</li>
</ul>
<h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><p>概念:同源策略是客户端脚本（尤其是<code>Javascript</code>）的重要的安全度量标准。它最早出自<code>Netscape Navigator2.0</code>，其目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p>
<p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h4 id="为什么要有同源限制？"><a href="#为什么要有同源限制？" class="headerlink" title="为什么要有同源限制？"></a>为什么要有同源限制？</h4><p>   我们举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p>
<p>缺点：</p>
<p>现在网站的<code>JS</code> 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 <code>merge</code> 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h4 id="GET和POST的区别，何时使用POST？"><a href="#GET和POST的区别，何时使用POST？" class="headerlink" title="GET和POST的区别，何时使用POST？"></a>GET和POST的区别，何时使用POST？</h4><pre><code>    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符

    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。


    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，

    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。



然而，在以下情况中，请使用 POST 请求：

无法使用缓存文件（更新服务器上的文件或数据库）

向服务器发送大量数据（POST 没有数据量限制）

发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><h4 id="事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><pre><code>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。

2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；

3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`;
</code></pre><h4 id="ajax的缺点和在IE下的问题？"><a href="#ajax的缺点和在IE下的问题？" class="headerlink" title="ajax的缺点和在IE下的问题？"></a>ajax的缺点和在IE下的问题？</h4><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<blockquote>
<p>ajax的缺点</p>
</blockquote>
<pre><code>1、ajax不支持浏览器back按钮。

2、安全问题 AJAX暴露了与服务器交互的细节。

3、对搜索引擎的支持比较弱。

4、破坏了程序的异常机制。

5、不容易调试。
</code></pre><blockquote>
<p>IE缓存问题</p>
</blockquote>
<p>在IE浏览器下，如果请求的方法是<code>GET</code>，并且请求的<code>URL</code>不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的<code>URL</code>，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(<code>&#39;t&#39;= + new Date().getTime()</code>)</p>
<p>或者：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span>(<span class="string">'GET'</span>,<span class="string">'demo.php?rand=+Math.random()'</span>,<span class="literal">true</span>);<span class="comment">//</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Ajax请求的页面历史记录状态问题</p>
</blockquote>
<p>可以通过锚点来记录状态，<code>location.hash</code>。让浏览器记录Ajax请求时页面状态的变化。</p>
<p>还可以通过<code>HTML5</code>的<code>history.pushState</code>，来实现浏览器地址栏的无刷新改变</p>
<h4 id="谈谈你对重构的理解"><a href="#谈谈你对重构的理解" class="headerlink" title="谈谈你对重构的理解"></a>谈谈你对重构的理解</h4><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，<br>在扩展的同时保持一致的UI。</p>
<pre><code>对于传统的网站来说重构通常是：

表格(table)布局改为DIV+CSS

使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)

对于移动平台的优化

针对于SEO进行优化

深层次的网站重构应该考虑的方面


减少代码间的耦合

让代码保持弹性

严格按规范编写代码

设计可扩展的API

代替旧有的框架、语言(如VB)

增强用户体验

通常来说对于速度的优化也包含在重构中



压缩JS、CSS、image等前端资源(通常是由服务器来解决)

程序的性能优化(如数据读写)

采用CDN来加速资源加载

对于JS DOM的优化

HTTP服务器的文件缓存
</code></pre><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</div><div class="line"></div><div class="line">200  OK   正常返回信息</div><div class="line"></div><div class="line">201  Created  请求成功并且服务器创建了新的资源</div><div class="line"></div><div class="line">202  Accepted  服务器已接受请求，但尚未处理</div><div class="line"></div><div class="line">301  Moved Permanently  请求的网页已永久移动到新位置。</div><div class="line"></div><div class="line">302 Found  临时性重定向。</div><div class="line"></div><div class="line">303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</div><div class="line"></div><div class="line">304  Not Modified  自从上次请求后，请求的网页未修改过。</div><div class="line"></div><div class="line"></div><div class="line">400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</div><div class="line"></div><div class="line">401 Unauthorized  请求未授权。</div><div class="line"></div><div class="line">403 Forbidden  禁止访问。</div><div class="line"></div><div class="line">404 Not Found  找不到如何与 URI 相匹配的资源。</div><div class="line"></div><div class="line">500 Internal Server Error  最常见的服务器端错误。</div><div class="line"></div><div class="line">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</div></pre></td></tr></table></figure>
<h4 id="说说你对Promise的理解"><a href="#说说你对Promise的理解" class="headerlink" title="说说你对Promise的理解"></a>说说你对Promise的理解</h4><p>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：</p>
<pre><code>pending: 初始状态, 非 fulfilled 或 rejected.

fulfilled: 成功的操作.

rejected: 失败的操作.

settled: Promise已被fulfilled或rejected，且不是pending
</code></pre><p>另外， <code>fulfilled</code> 与 <code>rejected</code> 一起合称 <code>settled</code>。</p>
<p><code>Promise</code> 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。</p>
<blockquote>
<p>Promise 的构造函数</p>
</blockquote>
<p>构造一个 <code>Promise</code>，最基本的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></div><div class="line"></div><div class="line">        resolve(result);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></div><div class="line"></div><div class="line">        reject(<span class="built_in">Error</span>(errMessage));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为 <code>thenable</code>）。它的使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在 <code>rejected</code> 的时候被调用，接收参数就是 <code>future，onFulfilled</code> 对应 <code>resolve</code>, <code>onRejected</code> 对应 <code>reject</code>。</p>
<h4 id="说说你对前端架构师的理解"><a href="#说说你对前端架构师的理解" class="headerlink" title="说说你对前端架构师的理解"></a>说说你对前端架构师的理解</h4><p>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；<br>带领团队完成研发工具及平台前端部分的设计、研发和维护；<br>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先<br>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。</p>
<h4 id="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</div><div class="line"></div><div class="line">                o[e] = <span class="keyword">typeof</span> <span class="keyword">this</span>[e] === <span class="string">"object"</span> ? <span class="keyword">this</span>[e].clone() : <span class="keyword">this</span>[e];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h4><p>严格模式主要有以下限制：</p>
<pre><code>变量必须声明后再使用

函数的参数不能有同名属性，否则报错

不能使用with语句

不能对只读属性赋值，否则报错

不能使用前缀0表示八进制数，否则报错

不能删除不可删除的属性，否则报错

不能删除变量delete prop，会报错，只能删除属性delete global[prop]

eval不会在它的外层作用域引入变量

eval和arguments不能被重新赋值

arguments不会自动反映函数参数的变化

不能使用arguments.callee

不能使用arguments.caller

禁止this指向全局对象

不能使用fn.caller和fn.arguments获取函数调用的堆栈

增加了保留字（比如protected、static和interface）
</code></pre><p>设立”严格模式”的目的，主要有以下几个：</p>
<ul>
<li><p>消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
</li>
<li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>
</li>
<li><p>提高编译器效率，增加运行速度；</p>
</li>
<li><p>为未来新版本的<code>Javascript</code>做好铺垫。</p>
</li>
</ul>
<p>注：经过测试<code>IE6,7,8,9</code>均不支持严格模式。</p>
<h4 id="如何删除一个cookie"><a href="#如何删除一个cookie" class="headerlink" title="如何删除一个cookie"></a>如何删除一个cookie</h4><blockquote>
<p>1.将时间设为当前时间往前一点。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line">date.setDate(date.getDate() - <span class="number">1</span>);<span class="comment">//真正的删除</span></div></pre></td></tr></table></figure>
<p><code>setDate()</code>方法用于设置一个月的某一天。</p>
<blockquote>
<p>2.expires的设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie = <span class="string">'user='</span>+ <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>)  + <span class="string">';expires = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h4 id="lt-strong-gt-，-lt-em-gt-和-lt-b-gt-，-lt-i-gt-标签"><a href="#lt-strong-gt-，-lt-em-gt-和-lt-b-gt-，-lt-i-gt-标签" class="headerlink" title="&lt;strong&gt;，&lt;em&gt;和&lt;b&gt;，&lt;i&gt;标签"></a><code>&lt;strong&gt;</code>，<code>&lt;em&gt;</code>和<code>&lt;b&gt;</code>，<code>&lt;i&gt;</code>标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span> 标签和 <span class="tag">&lt;<span class="name">em</span>&gt;</span> 标签一样，用于强调文本，但它强调的程度更强一些。</div><div class="line"></div><div class="line">em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 <span class="tag">&lt;<span class="name">i</span>&gt;</span>...<span class="tag">&lt;/<span class="name">i</span>&gt;</span>;</div><div class="line"></div><div class="line"><span class="tag">&lt; <span class="attr">b</span> &gt;</span> <span class="tag">&lt; <span class="attr">i</span> &gt;</span>是视觉要素，分别表示无意义的加粗，无意义的斜体。</div><div class="line"></div><div class="line">em 和 strong 是表达要素(phrase elements)。</div></pre></td></tr></table></figure>
<h4 id="说说你对AMD和Commonjs的理解"><a href="#说说你对AMD和Commonjs的理解" class="headerlink" title="说说你对AMD和Commonjs的理解"></a>说说你对AMD和Commonjs的理解</h4><p><code>CommonJS</code>是服务器端模块的规范，Node.js采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<blockquote>
<p>详情：<a href="https://segmentfault.com/a/1190000004888589" target="_blank" rel="external">也谈webpack及其开发模式</a></p>
</blockquote>
<h4 id="document-write-的用法"><a href="#document-write-的用法" class="headerlink" title="document.write()的用法"></a>document.write()的用法</h4><p><code>document.write()</code>方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。</p>
<p><code>document.write</code>只能重绘整个页面。<code>innerHTML</code>可以重绘页面的一部分</p>
<h4 id="编写一个方法-求一个字符串的字节长度"><a href="#编写一个方法-求一个字符串的字节长度" class="headerlink" title="编写一个方法 求一个字符串的字节长度"></a>编写一个方法 求一个字符串的字节长度</h4><p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> len = str.length;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> bytes = len;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) bytes++;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> bytes;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">alert(GetBytes(<span class="string">"你好,as"</span>));</div></pre></td></tr></table></figure>
<h3 id="git-fetch和git-pull的区别"><a href="#git-fetch和git-pull的区别" class="headerlink" title="git fetch和git pull的区别"></a>git fetch和git pull的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git pull：相当于是从远程获取最新版本并merge到本地</div><div class="line"></div><div class="line">git fetch：相当于是从远程获取最新版本到本地，不会自动merge</div></pre></td></tr></table></figure>
<h4 id="说说你对MVC和MVVM的理解"><a href="#说说你对MVC和MVVM的理解" class="headerlink" title="说说你对MVC和MVVM的理解"></a>说说你对MVC和MVVM的理解</h4><blockquote>
<p><code>MVC</code></p>
</blockquote>
<pre><code>View 传送指令到 Controller

Controller 完成业务逻辑后，要求 Model 改变状态

Model 将新的数据发送到 View，用户得到反馈
</code></pre><p>所有通信都是单向的。</p>
<p><code>Angular</code>它采用双向绑定（data-binding）：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然。</p>
<pre><code>组成部分Model、View、ViewModel

View：UI界面

ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；

Model：数据访问层
</code></pre><h4 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" class="headerlink" title="请解释什么是事件代理"></a>请解释什么是事件代理</h4><p>事件代理（Event Delegation），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是<code>DOM</code>元素的事件冒泡。使用事件代理的好处是可以提高性能。</p>
<h4 id="attribute和property的区别是什么？"><a href="#attribute和property的区别是什么？" class="headerlink" title="attribute和property的区别是什么？"></a>attribute和property的区别是什么？</h4><p><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</p>
<p><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</p>
<p>所以：</p>
<p>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的，</p>
<p>但是对于自定义的属性来说，他们是不同步的，</p>
<h4 id="说说网络分层里七层模型是哪七层"><a href="#说说网络分层里七层模型是哪七层" class="headerlink" title="说说网络分层里七层模型是哪七层"></a>说说网络分层里七层模型是哪七层</h4><ul>
<li><p>应用层：应用层、表示层、会话层（从上往下）（<code>HTTP、FTP、SMTP、DNS</code>）</p>
</li>
<li><p>传输层（<code>TCP</code>和<code>UDP</code>）</p>
</li>
<li><p>网络层（<code>IP</code>）</p>
</li>
<li><p>物理和数据链路层（以太网）</p>
</li>
</ul>
<blockquote>
<p>每一层的作用如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</div><div class="line">数据链路层：将比特组装成帧和点到点的传递（帧Frame）</div><div class="line">网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</div><div class="line">传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</div><div class="line">会话层：建立、管理和终止会话（会话协议数据单元SPDU）</div><div class="line">表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</div><div class="line">应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</div></pre></td></tr></table></figure>
<blockquote>
<p>各种协议</p>
</blockquote>
<p><code>ICMP协议</code>： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br><code>TFTP协议</code>： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br><code>HTTP协议</code>： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br><code>DHCP协议</code>： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<h4 id="说说mongoDB和MySQL的区别"><a href="#说说mongoDB和MySQL的区别" class="headerlink" title="说说mongoDB和MySQL的区别"></a>说说mongoDB和MySQL的区别</h4><p><code>MySQL</code>是传统的关系型数据库，<code>MongoDB</code>则是非关系型数据库</p>
<p> <code>mongodb</code>以<code>BSON</code>结构（二进制）进行存储，对海量数据存储有着很明显的优势。</p>
<p>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：<br>①弱一致性（最终一致），更能保证用户的访问速度：<br>②文档结构的存储方式，能够更便捷的获取数据。</p>
<h4 id="讲讲304缓存的原理"><a href="#讲讲304缓存的原理" class="headerlink" title="讲讲304缓存的原理"></a>讲讲304缓存的原理</h4><p>服务器首先产生<code>ETag</code>，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>
<p><br></p>
<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>
<p><br></p>
<p>客户端请求一个页面（A）。 服务器返回页面A，并在给<code>A</code>加上一个<code>ETag</code>。 客户端展现该页面，并将页面连同<code>ETag</code>一起缓存。 客户再次请求页面<code>A</code>，并将上次请求时服务器返回的<code>ETag</code>一起传递给服务器。 服务器检查该<code>ETag</code>，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应<code>304</code>（未修改——<code>Not Modified</code>）和一个空的响应体。</p>
<p><br></p>
<h4 id="什么样的前端代码是好的"><a href="#什么样的前端代码是好的" class="headerlink" title="什么样的前端代码是好的"></a>什么样的前端代码是好的</h4><p>高复用低耦合，这样文件小，好维护，而且好扩展。</p>
<h4 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h4><ul>
<li><a href="./readme.html">css代码题</a></li>
<li><a href="./readme.js">js代码题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一些开放性题目&quot;&gt;&lt;a href=&quot;#一些开放性题目&quot; class=&quot;headerlink&quot; title=&quot;一些开放性题目&quot;&gt;&lt;/a&gt;一些开放性题目&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。

2.项目介绍

3.如何看待前端开发？

4.平时是如何学习前端开发的？

5.未来三到五年的规划是怎样的？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://damonare.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="HTTP" scheme="http://damonare.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Hexo折腾记</title>
    <link href="http://damonare.github.io/2016/09/06/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>http://damonare.github.io/2016/09/06/Hexo折腾记/</id>
    <published>2016-09-05T16:17:05.192Z</published>
    <updated>2016-09-06T11:22:47.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>如果时间可以静止，我希望就停在此刻。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>博主之前也有折腾wordpress和jekyll可对于一个前端er来说，wordpress让人没法尽兴，因为不知道该如何添加自己的代码。而jekyll就太麻烦了每一次都需要重新提交，而且样式也不是很丰富，简直就和鸡肋一般。食之无味，弃之可惜。</p>
</blockquote>
<a id="more"></a>
<p><strong>之前有听说过Hexo这个博客框架，但一直没时间给自己搭一个，其实平时也有注意到很多大牛的博客是很绚丽的，却不知道那就是Hexo。说干就干，历时一整天，踩坑无数，终于变成了博主想要的样子。放个链接<a href="https://damonare.github.io">Damonare的个人博客</a>如果你也想要一个和博主一样的博客，那就继续看下去吧。</strong></p>
<ul>
<li>博主系统Window7,搭建博客主题Yilia。下面记录博主搭建的整个过程。</li>
</ul>
<h2 id="git和github"><a href="#git和github" class="headerlink" title="git和github"></a>git和github</h2><blockquote>
<ul>
<li>想搭建一个博客的应该大多数都是程序员吧，那么github账号应该是一定有的了。你要是实在清新脱俗到连个github账号也没有，不用担心，给你个外链<a href="https://github.com" target="_blank" rel="external">Github</a>,账号设置然后添加SSH,这样你之后输入hexo命令的时候就不用一次次输入密码了，关于如何注册github和添加SSH，这里需要提醒一点，github账号最好都是小写字母，不然容易解析错误，还有邮箱，尽量别用国内的邮箱，很容易出问题了，比如你git提交的贡献不被记录。</li>
<li>Git身为程序员给他应该是会用的吧。好吧假设你不会使用git和github给你个外链<a href="http://www.cnblogs.com/peterzd/archive/2012/04/22/2465230.html" target="_blank" rel="external">看这里</a></li>
</ul>
</blockquote>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul>
<li><p>好的，现在你有了github和git了，也配置好了，那么就需要在github新建一个仓库了,</p>
<p><img src="http://img.blog.csdn.net/20160906153800293" alt="这里写图片描述"></p>
<p><strong>注意：这里的仓库名称要和你的username对应</strong></p>
</li>
<li>Node安装</li>
</ul>
<blockquote>
<p>Node可以去官网下载，或是在国内下载，由于众所周知的原因，这里放一个<a href="http://nodejs.cn/" target="_blank" rel="external">nodejs.cn</a>的链接<br>Node内置npm包，我们之后就可以打开node命令行使用npm进行安装一些依赖，如果觉得太慢，可以使用淘宝镜像cnpm</p>
</blockquote>
<ul>
<li>Hexo安装</li>
</ul>
<blockquote>
<p>好的，现在我们Node,git,github都弄好了，现在可以本地化一个hexo了,新建hexo文件夹，任意盘下都可以，然后命令行执行命令：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> hexo -g  <span class="comment">#-g表示全局安装, npm默认为当前项目安装</span></div></pre></td></tr></table></figure></p>
<p>如果遇到错误：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div></pre></td></tr></table></figure></p>
<p>改用下面的命令安装：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> install hexo --<span class="literal">no</span>-optional</div></pre></td></tr></table></figure></p>
<p>好的，现在hexo也就绪了,hexo命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/git</div><div class="line">hexo init hexo  <span class="comment">#执行init命令初始化到你指定的hexo目录</span></div><div class="line"><span class="built_in">cd</span> hexo</div><div class="line">npm install    <span class="comment">#install before start blogging</span></div><div class="line">hexo generate       <span class="comment">#自动根据当前目录下文件,生成静态网页</span></div><div class="line">hexo server         <span class="comment">#运行本地服务</span></div></pre></td></tr></table></figure>
<blockquote>
<p>浏览器输入<a href="http://localhost:4000就可以看到效果。" target="_blank" rel="external">http://localhost:4000就可以看到效果。</a><br> <strong>浏览目录</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">├── .deploy       <span class="meta">#需要部署的文件</span></div><div class="line">├── node_modules  <span class="meta">#Hexo插件</span></div><div class="line">├── <span class="keyword">public</span>        <span class="meta">#生成的静态网页文件</span></div><div class="line">├── scaffolds     <span class="meta">#模板</span></div><div class="line">├── source        <span class="meta">#博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span></div><div class="line">|   ├── _drafts   <span class="meta">#草稿</span></div><div class="line">|   └── _posts    <span class="meta">#文章</span></div><div class="line">├── themes        <span class="meta">#主题</span></div><div class="line">├── _config.yml   <span class="meta">#全局配置文件</span></div><div class="line">└── <span class="keyword">package</span>.json</div></pre></td></tr></table></figure></p>
<p>添加博文<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span>  <span class="meta">#新建博文,其中postName是博文题目</span></div></pre></td></tr></table></figure></p>
<p>如果不想博文在首页全部显示, 并能出现阅读全文按钮效果, 需要在你想在首页显示的部分下添加</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--more--&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这点和wordpress是一样的</p>
</blockquote>
<h2 id="Hexo-Yilia主题配置"><a href="#Hexo-Yilia主题配置" class="headerlink" title="Hexo Yilia主题配置"></a>Hexo Yilia主题配置</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">~/git/</span>hexo</div><div class="line">git clone git<span class="meta">@github</span>.<span class="string">com:</span>litten<span class="regexp">/hexo-theme-yilia.git themes/</span>yilia</div></pre></td></tr></table></figure>
<blockquote>
<p>在./_config.yml，修改主题为yilia<br>theme: yilia</p>
<p>Hexo <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题</a></p>
</blockquote>
<p>查看本地效果<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">hexo g</span></div><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<h3 id="完整配置信息如下："><a href="#完整配置信息如下：" class="headerlink" title="完整配置信息如下："></a>完整配置信息如下：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site #站点信息</span></div><div class="line"><span class="attr">title:</span> blog Name <span class="comment">#标题</span></div><div class="line"><span class="attr">subtitle:</span> Subtitle <span class="comment">#副标题</span></div><div class="line"><span class="attr">description:</span> my blog desc <span class="comment">#描述</span></div><div class="line"><span class="attr">author:</span> me <span class="comment">#作者</span></div><div class="line"><span class="attr">language:</span> zh-CN <span class="comment">#语言</span></div><div class="line"><span class="attr">timezone:</span> Asia/Shanghai <span class="comment">#时区</span></div><div class="line"></div><div class="line"><span class="comment"># URL</span></div><div class="line"><span class="attr">url:</span> http://yoururl.com   <span class="comment">#用于绑定域名, 其他的不需要配置</span></div><div class="line"><span class="attr">root:</span> /</div><div class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></div><div class="line"><span class="attr">permalink:</span> posts/title.html</div><div class="line"><span class="attr">permalink_defaults:</span></div><div class="line"></div><div class="line"><span class="comment"># Directory #目录</span></div><div class="line"><span class="attr">source_dir:</span> source <span class="comment">#源文件</span></div><div class="line"><span class="attr">public_dir:</span> public <span class="comment">#生成的网页文件</span></div><div class="line"><span class="attr">tag_dir:</span> tags <span class="comment">#标签</span></div><div class="line"><span class="attr">archive_dir:</span> archives <span class="comment">#归档</span></div><div class="line"><span class="attr">category_dir:</span> categories <span class="comment">#分类</span></div><div class="line"><span class="attr">code_dir:</span> downloads/code</div><div class="line"><span class="attr">i18n_dir:</span> :lang <span class="comment">#国际化</span></div><div class="line"><span class="attr">skip_render:</span></div><div class="line"></div><div class="line"><span class="comment"># Writing #写作</span></div><div class="line"><span class="attr">new_post_name:</span> :title.md <span class="comment">#新文章标题</span></div><div class="line"><span class="attr">default_layout:</span> post <span class="comment">#默认模板(post page photo draft)</span></div><div class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment">#标题转换成大写</span></div><div class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment">#新标签页里打开连接</span></div><div class="line"><span class="attr">filename_case:</span> <span class="number">0</span></div><div class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></div><div class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></div><div class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></div><div class="line"><span class="attr">future:</span> <span class="literal">true</span></div><div class="line"><span class="attr">highlight:</span> <span class="comment">#语法高亮</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  line_number:</span> <span class="literal">true</span> <span class="comment">#显示行号</span></div><div class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  tab_replace:</span></div><div class="line"></div><div class="line"><span class="comment"># Category &amp; Tag #分类和标签</span></div><div class="line"><span class="attr">default_category:</span> uncategorized <span class="comment">#默认分类</span></div><div class="line"><span class="attr">category_map:</span></div><div class="line"><span class="attr">tag_map:</span></div><div class="line"></div><div class="line"><span class="comment"># Date / Time format #日期时间格式</span></div><div class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></div><div class="line"><span class="attr">date_format:</span> YYYY-MM-DD</div><div class="line"><span class="attr">time_format:</span> HH:mm:ss</div><div class="line"></div><div class="line"><span class="comment"># Pagination #分页</span></div><div class="line"><span class="attr">per_page:</span> <span class="number">10</span> <span class="comment">#每页文章数, 设置成 0 禁用分页</span></div><div class="line"><span class="attr">pagination_dir:</span> page</div><div class="line"></div><div class="line"><span class="comment"># Extensions #插件和主题</span></div><div class="line"><span class="comment">## 插件: http://hexo.io/plugins/</span></div><div class="line"><span class="comment">## 主题: http://hexo.io/themes/</span></div><div class="line"><span class="attr">theme:</span> next</div><div class="line"></div><div class="line"><span class="comment"># Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面</span></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">- type:</span> git</div><div class="line"><span class="attr">  repo:</span> git@gitcafe.com:username/username.git,gitcafe-pages</div><div class="line"><span class="attr">- type:</span> git</div><div class="line"><span class="attr">  repo:</span> git@github.com:username/username.github.io.git,master</div><div class="line"></div><div class="line"><span class="comment"># Disqus #Disqus评论系统</span></div><div class="line"><span class="attr">disqus_shortname:</span></div><div class="line"></div><div class="line"><span class="attr">plugins:</span> <span class="comment">#插件，例如生成 RSS 和站点地图的</span></div><div class="line"><span class="bullet">-</span> hexo-generator-feed</div><div class="line"><span class="bullet">-</span> hexo-generator-sitemap</div></pre></td></tr></table></figure>
<blockquote>
<p>其它设置，可参考：<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="external">这篇博文</a></p>
</blockquote>
<h3 id="Hexo-Yilia-Bug修改"><a href="#Hexo-Yilia-Bug修改" class="headerlink" title="Hexo Yilia Bug修改"></a>Hexo Yilia Bug修改</h3><blockquote>
<p>修改参考<a href="https://github.com/litten/hexo-theme-yilia/issues" target="_blank" rel="external">这里</a>基本所有的问题都能在这里解决了,所以啊，一个项目的issue真的很具有参考价值，少走不少弯路，通过这里的代码博主添加了 Hexo文章统计 功能，没有动画，头像设置有null的问题以及点击小房子没反应的bug。</p>
</blockquote>
<p>&gt;</p>
<h2 id="Hexo添加文章目录"><a href="#Hexo添加文章目录" class="headerlink" title="Hexo添加文章目录"></a>Hexo添加文章目录</h2><blockquote>
<p>我们首先要编辑文章显示页面的模板，也就是<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">themes<span class="regexp">/landscape/</span>layout<span class="regexp">/_partial/</span>article.ejs</div></pre></td></tr></table></figure></p>
<p>文件。为了将目录生成在正文之前，我们首先在这个文件中找到<br><figure class="highlight erb"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby"> post.content </span><span class="xml"><span class="tag">%&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>并在这一行之前加入如下代码：</p>
</blockquote>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="comment">&lt;!-- Table of Contents --&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span><span class="perl"> <span class="keyword">if</span> (!<span class="keyword">index</span> &amp;&amp; post.toc)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toc"</span> <span class="attr">class</span>=<span class="string">"toc-article"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">"toc-title"</span>&gt;</span>文章目录<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span><span class="perl">- toc(post.content) </span><span class="xml"><span class="tag">%&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span><span class="perl"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的含义清晰明了，if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的div。</p>
<p>修改完这个文件之后，找一篇包含了多个子标题的文章，并在文章开头的front-matter中添加一句toc: true，在浏览器中访问这篇文章，应该可以看到文章的开头处已经有了带链接的目录。但是这样的目录实在太难看，我们还需要添加相应的CSS来将其指定为我们想要的样式。</p>
<p>要指定目录的样式，我们要修改的文件是<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">themes<span class="regexp">/landscape/</span><span class="keyword">source</span><span class="regexp">/css/</span>_partial<span class="regexp">/article.styl</span></div></pre></td></tr></table></figure></p>
<p>在文件的最后，添加如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*toc*/</span></div><div class="line"><span class="selector-class">.toc-article</span></div><div class="line">	<span class="attribute">background</span> <span class="number">#eee</span></div><div class="line">	<span class="attribute">border</span> <span class="number">1px</span> solid <span class="number">#bbb</span></div><div class="line">	<span class="attribute">border-radius</span> <span class="number">10px</span></div><div class="line">	<span class="attribute">margin</span> <span class="number">1.5em</span> <span class="number">0</span> <span class="number">0.3em</span> <span class="number">1.5em</span></div><div class="line">	<span class="attribute">padding</span> <span class="number">1.2em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">1em</span></div><div class="line">	<span class="attribute">max-width</span> <span class="number">28%</span></div><div class="line"></div><div class="line"><span class="selector-class">.toc-title</span></div><div class="line">	<span class="attribute">font-size</span> <span class="number">120%</span></div><div class="line"></div><div class="line"><span class="selector-id">#toc</span></div><div class="line">	<span class="attribute">line-height</span> <span class="number">1em</span></div><div class="line">	<span class="attribute">font-size</span> <span class="number">0.9em</span></div><div class="line">	<span class="attribute">float</span> right</div><div class="line"><span class="selector-class">.toc</span></div><div class="line">	<span class="attribute">padding</span> <span class="number">0</span></div><div class="line">	<span class="attribute">margin</span> <span class="number">1em</span></div><div class="line">	<span class="attribute">line-height</span> <span class="number">1.8em</span></div><div class="line">	<span class="selector-tag">li</span></div><div class="line">	<span class="attribute">list-style-type</span> none</div><div class="line"></div><div class="line"><span class="selector-class">.toc-child</span></div><div class="line">	<span class="attribute">margin-left</span> <span class="number">1em</span></div></pre></td></tr></table></figure>
<p>由于Hexo使用的是stylus预处理器，所以CSS代码要注意缩进，不然就报错了，这种目录要是不满意完全可以按照自己意愿写一个。</p>
</blockquote>
<h2 id="Hexo-多说评论框"><a href="#Hexo-多说评论框" class="headerlink" title="Hexo 多说评论框"></a>Hexo 多说评论框</h2><blockquote>
<p>链接：<a href="http://ssk.91txh.com/205" target="_blank" rel="external">多说社会化评论框核心脚本embed.js本地化方法</a><br>链接：<a href="http://ssk.91txh.com/207" target="_blank" rel="external">多说社会化评论框添加 站长回复 标记</a><br>链接： <a href="http://ssk.91txh.com/209" target="_blank" rel="external">多说回复后显示浏览器及操作系统信息（Useragent）</a></p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>有任何问题请在评论中回复，博主会在评论中解答。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果时间可以静止，我希望就停在此刻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;博主之前也有折腾wordpress和jekyll可对于一个前端er来说，wordpress让人没法尽兴，因为不知道该如何添加自己的代码。而jekyll就太麻烦了每一次都需要重新提交，而且样式也不是很丰富，简直就和鸡肋一般。食之无味，弃之可惜。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活" scheme="http://damonare.github.io/categories/life/"/>
    
    
      <category term="Hexo" scheme="http://damonare.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Javascript作用域总结</title>
    <link href="http://damonare.github.io/2016/09/06/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/09/06/javascript作用域总结/</id>
    <published>2016-09-05T16:04:16.808Z</published>
    <updated>2016-09-06T04:05:45.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。</p>
</blockquote>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><a id="more"></a>
<p><strong>这个应该好理解，函数作用域就是说定义在函数中的参数和变量在函数外部是不可见的。</strong></p>
<p><strong>大多数类C语言都拥有块级作用域，JS却没有。请看下文demo:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C语言</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line">i--;</div><div class="line"><span class="keyword">if</span>(i)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> j=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d/n"</span>,j);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>运行这段代码，会出现“use an undefined variable:j”的错误。可以看到，C语言拥有块级作用域，因为j是在if的语句块中定义的，因此，它在块外是无法访问的。</strong></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><hr>
<blockquote>
<p>任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>
</blockquote>
<p>正如我们举的C语言的例子，大多数类C语言都是有块级作用域的，那么在JavaScript又有什么不同呢？</p>
<p><strong>我们一起看看这个JavaScript的demo:</strong><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">functin <span class="keyword">test</span>()&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=0;i&lt;3;i++)&#123;</div><div class="line">&#125;</div><div class="line">alert(i);</div><div class="line">&#125;</div><div class="line"><span class="keyword">test</span>();</div></pre></td></tr></table></figure></p>
<p><strong>运行这段代码，弹出”3”，可见，在块外，块中定义的变量i仍然是可以访问的。也就是说，JS并不支持块级作用域，它只支持函数作用域，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都是可见的。</strong></p>
<p><strong>那么我们该如何使JS拥有块级作用域呢？是否还记得，在一个函数中定义的变量，当这个函数调用完后，变量会被销毁，我们是否可以用这个特性来模拟出JS的块级作用域呢？看下面这个demo：</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span>&#123;</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span>&#123;</span></div><div class="line"><span class="keyword">for</span>(var <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;<span class="number">4</span>;<span class="built_in">i</span>++)&#123;</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line">alert(<span class="built_in">i</span>);</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p><strong>这时候再次运行，会弹出”i”未定义的错误，哈哈，实现了吧~~~这里，我们把for语句块放到了一个闭包之中，然后调用这个函数，当函数调用完毕，变量i自动销毁，因此，我们在块外便无法访问了。</strong></p>
<p><strong>JS的闭包特性is the most important feature((<em>^__^</em>) 大家懂的)。在JS中，为了防止命名冲突，我们应该尽量避免使用全局变量和全局函数。那么，该如何避免呢？不错，正如上文demo所示，我们可以把要定义的所有内容放入到一个</strong><br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span> ()&#123;</div><div class="line">//内容</div><div class="line">&#125;)()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p><strong>之中，这时候，我们是不是相当于给它们的外层添加了一个函数作用域呢？该作用域之外的程序是无法访问它们的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数作用域&quot;&gt;&lt;a href=&quot;#函数作用域&quot; class=&quot;headerlink&quot; title=&quot;函数作用域&quot;&gt;&lt;/a&gt;函数作用域&lt;/h3&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript闭包总结</title>
    <link href="http://damonare.github.io/2016/09/06/javscript%E9%97%AD%E5%8C%85%E6%B5%85%E8%B0%88/"/>
    <id>http://damonare.github.io/2016/09/06/javscript闭包浅谈/</id>
    <published>2016-09-05T16:02:50.096Z</published>
    <updated>2016-09-06T04:06:33.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript的闭包"><a href="#JavaScript的闭包" class="headerlink" title="JavaScript的闭包"></a>JavaScript的闭包</h2><hr>
<p>&nbsp;&nbsp;其实关于闭包各个论坛社区里都有很多的文章来讲它，毕竟闭包是JavaScript中一个特色，也正因为这个雨中不同的特色也让闭包理解起来有一些吃力。笔者在这里不仅仅是想介绍闭包，也向列举一些笔者所见过的一些闭包，如果有读者还有一些比较经典的闭包例子，希望可以在评论区里留一下，谢谢。</p>
<a id="more"></a>
<p><strong>说了半天，究竟什么是闭包呢？</strong></p>
<ul>
<li>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</li>
<li>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。</li>
<li>当在一个函数内定义另外一个函数就会产生闭包。</li>
</ul>
<p><strong>为了便于理解，我们可以简单的将闭包理解为：</strong></p>
<ul>
<li>闭包：是指有权访问另外一个函数作用域中的变量的函数。</li>
</ul>
<h3 id="JavaScript中的作用域"><a href="#JavaScript中的作用域" class="headerlink" title="JavaScript中的作用域"></a>JavaScript中的作用域</h3><hr>
<p>&nbsp;&nbsp;<strong>JavaScript中是没有块级作用域的。不过关于块级作用域我们在这里不做深入探究，笔者在<a><a href="http://segmentfault.com/a/1190000004092842M" target="_blank" rel="external">http://segmentfault.com/a/1190000004092842M</a></a>中有对块级作用域较为详细的解释，不懂的读者可以去看看。</strong></p>
<blockquote>
<p>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　  <span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">&#123;</span></span></div><div class="line">　　　　alert(n);</div><div class="line">　　&#125;</div><div class="line">　　<span class="title">f1</span><span class="params">()</span>; <span class="comment">// 999</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>如上函数，f1可调用全局变量n</strong></p>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　&#125;</div><div class="line">　　alert(n); <span class="comment">// error</span></div></pre></td></tr></table></figure>
<p><strong>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。</strong></p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">&#123;</span></span></div><div class="line">　　　　n=999;</div><div class="line">　　&#125;</div><div class="line">　　<span class="title">f1</span><span class="params">()</span>;</div><div class="line">　　alert(n); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
<p>###闭包</p>
<p><strong>1.理解闭包</strong></p>
<p><strong>我们已经理解了什么是作用域，什么是块级作用域，那又该如何去访问函数内部的变量呢？</strong></p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　　　&#125;</div><div class="line"><span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　<span class="keyword">var</span> result=f1();</div><div class="line">　result();<span class="comment">// 弹出999</span></div></pre></td></tr></table></figure></p>
<p><strong>上面函数中的f2函数就是闭包，就是通过建立函数来访问函数内部的局部变量。</strong></p>
<p><strong>2.闭包的用途</strong><br>&nbsp;&nbsp;闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div><div class="line">　　nAdd();</div><div class="line">　　result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure></p>
<p><strong>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</strong></p>
<p><strong>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</strong></p>
<p><strong>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</strong></p>
<p><strong>3.闭包的注意点</strong></p>
<blockquote>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
</blockquote>
<p><strong>4.经典闭包小案例</strong></p>
<p><strong>如果你能理解下面全部的案例，那你的闭包就算是真正掌握了。</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　name : <span class="string">"My Object"</span>,</div><div class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//The Window</span></div></pre></td></tr></table></figure></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">　  <span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　name : <span class="string">"My Object"</span>,</div><div class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> that.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//My Object</span></div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="title">fun</span><span class="params">(n,o)</span></span> &#123;</div><div class="line">  console.log(o)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span>:<span class="title">function</span><span class="params">(m)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(m,n)</span></span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>;  a.<span class="keyword">fun</span>(<span class="number">1</span>);  a.<span class="keyword">fun</span>(<span class="number">2</span>);  a.<span class="keyword">fun</span>(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> b = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>).<span class="keyword">fun</span>(<span class="number">2</span>).<span class="keyword">fun</span>(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> c = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>);  c.<span class="keyword">fun</span>(<span class="number">2</span>);  c.<span class="keyword">fun</span>(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div></pre></td></tr></table></figure>
<blockquote>
<p>//问:三行a,b,c的输出分别是什么？</p>
</blockquote>
<p><strong>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</strong></p>
<blockquote>
<p>//答案：<br>//a: undefined,0,0,0<br>//b: undefined,0,1,2<br>//c: undefined,0,1,1</p>
</blockquote>
<p><strong>都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript的闭包&quot;&gt;&lt;a href=&quot;#JavaScript的闭包&quot; class=&quot;headerlink&quot; title=&quot;JavaScript的闭包&quot;&gt;&lt;/a&gt;JavaScript的闭包&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;其实关于闭包各个论坛社区里都有很多的文章来讲它，毕竟闭包是JavaScript中一个特色，也正因为这个雨中不同的特色也让闭包理解起来有一些吃力。笔者在这里不仅仅是想介绍闭包，也向列举一些笔者所见过的一些闭包，如果有读者还有一些比较经典的闭包例子，希望可以在评论区里留一下，谢谢。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS居中小谈</title>
    <link href="http://damonare.github.io/2016/09/06/CSS%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B0%88/"/>
    <id>http://damonare.github.io/2016/09/06/CSS居中小谈/</id>
    <published>2016-09-05T16:01:12.627Z</published>
    <updated>2016-09-06T04:06:17.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了。</p>
</blockquote>
<a id="more"></a>
<h1 id="内联元素居中方案"><a href="#内联元素居中方案" class="headerlink" title="内联元素居中方案"></a>内联元素居中方案</h1><p><strong>水平居中设置：</strong></p>
<ol>
<li><p>行内元素 设置 text-align:center；</p>
</li>
<li><p>Flex布局 设置display:flex;justify-content:center;(灵活运用)</p>
</li>
</ol>
<p><strong>垂直居中设置：</strong></p>
<ol>
<li>父元素高度确定的单行文本（内联元素） 设置 height = line-height；</li>
<li><p>父元素高度确定的多行文本（内联元素） a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle； b:先设置 display:table-cell 再设置 vertical-align:middle；</p>
<h2 id="块级元素居中方案"><a href="#块级元素居中方案" class="headerlink" title="块级元素居中方案"></a>块级元素居中方案</h2><p><strong>水平居中设置：</strong></p>
</li>
<li><p>定宽块状元素 设置 左右 margin 值为 auto；</p>
</li>
<li><p>不定宽块状元素 a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto； b:给该元素设置 displa:inine 方法； c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%；</p>
</li>
</ol>
<p><strong>垂直居中设置：</strong></p>
<ul>
<li><p>1.使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性;</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line"><span class="attribute">position</span>:absolute;<span class="comment">/*或fixed*/</span></div><div class="line"><span class="attribute">top</span>:<span class="number">50%</span>;</div><div class="line"><span class="attribute">left</span>:<span class="number">50%</span>;</div><div class="line"><span class="attribute">margin-top</span>:-<span class="number">100px</span>;</div><div class="line"><span class="attribute">margin-left</span>:-<span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2.利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了;</li>
</ul>
</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;或fixed</div><div class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3.利用display:table-cell属性使内容垂直居中;</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line"></div><div class="line"><span class="attribute">display</span>:table-cell;</div><div class="line"></div><div class="line"><span class="attribute">vertical-align</span>:middle;</div><div class="line"></div><div class="line"><span class="attribute">text-align</span>:center;</div><div class="line"></div><div class="line"><span class="attribute">width</span>:<span class="number">120px</span>;</div><div class="line"></div><div class="line"><span class="attribute">height</span>:<span class="number">120px</span>;</div><div class="line"></div><div class="line"><span class="attribute">background</span>:purple;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>4.使用css3的新属性transform:translate(x,y)属性;</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(50%,50%);</div><div class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">translate</span>(50%,50%);</div><div class="line">    <span class="attribute">-moz-transform</span>:<span class="built_in">translate</span>(50%,50%);</div><div class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">translate</span>(50%,50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>5.最高大上的一种，使用:before元素;</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line"></div><div class="line"><span class="attribute">position</span>:fixed;</div><div class="line"></div><div class="line"><span class="attribute">display</span>:block;</div><div class="line"></div><div class="line"><span class="attribute">background</span>:<span class="built_in">rgba</span>(0,0,0,.5);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line"></div><div class="line"><span class="attribute">content</span>:<span class="string">''</span>;</div><div class="line"></div><div class="line"><span class="attribute">display</span>:inline-block;</div><div class="line"></div><div class="line"><span class="attribute">vertical-align</span>:middle;</div><div class="line"></div><div class="line"><span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span><span class="selector-class">.content</span>&#123;</div><div class="line"></div><div class="line"><span class="attribute">width</span>:<span class="number">60px</span>;</div><div class="line"></div><div class="line"><span class="attribute">height</span>:<span class="number">60px</span>;</div><div class="line"></div><div class="line"><span class="attribute">line-height</span>:<span class="number">60px</span>;</div><div class="line"></div><div class="line"><span class="attribute">color</span>:red;</div></pre></td></tr></table></figure>
<ul>
<li>6.Flex布局;</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">    <span class="attribute">display</span>: -webkit-box;</div><div class="line">    <span class="attribute">display</span>: -webkit-flex;</div><div class="line">    <span class="attribute">display</span>: -moz-box;</div><div class="line">    <span class="attribute">display</span>: -moz-flex;</div><div class="line">    <span class="attribute">display</span>: -ms-flexbox;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    水平居中</div><div class="line">    -webkit-box-align: center;</div><div class="line">    -moz-box-align: center;</div><div class="line">    -ms-<span class="attribute">flex</span>-pack:center;</div><div class="line">    -webkit-<span class="attribute">justify-content</span>: center;</div><div class="line">    -moz-<span class="attribute">justify-content</span>: center;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">     垂直居中</div><div class="line">    -webkit-box-pack: center;</div><div class="line">    -moz-box-pack: center;</div><div class="line">    -ms-<span class="attribute">flex</span>-align:center;</div><div class="line">    -webkit-<span class="attribute">align-items</span>: center;</div><div class="line">    -moz-<span class="attribute">align-items</span>: center;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote>
<p>博主暂时掌握了这些居中方法，读者如果还有好方法或是觉得那个地方不对，欢迎评论，不吝感谢。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS清除浮动</title>
    <link href="http://damonare.github.io/2016/09/05/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <id>http://damonare.github.io/2016/09/05/CSS清除浮动/</id>
    <published>2016-09-05T15:59:07.116Z</published>
    <updated>2016-09-06T04:06:22.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CSS清除浮动？"><a href="#什么是CSS清除浮动？" class="headerlink" title="什么是CSS清除浮动？"></a>什么是CSS清除浮动？</h2><blockquote>
<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p>
</blockquote>
<a id="more"></a>
<p><strong>引用W3C的例子，news容器没有包围浮动的元素。</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="selector-class">.news</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  &#125;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"news"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">img</span> src=<span class="string">"news-pic.jpg"</span> /&gt;</div><div class="line">&lt;p&gt;some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="http://images.cnitblog.com/blog/349636/201310/23224343-9668661a8f63445699e0a8c24a64662b.jpg" alt="图片">;</p>
<h2 id="清除浮动方法"><a href="#清除浮动方法" class="headerlink" title="清除浮动方法"></a>清除浮动方法</h2><p><strong>方法一：使用带clear属性的空元素</strong></p>
<p>在浮动元素后使用一个空元素如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"clear"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>，并在CSS中赋予<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clear</span>&#123;<span class="attribute">clear</span>:both;&#125;</div></pre></td></tr></table></figure></p>
<p>属性即可清理浮动。亦可使用</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;br <span class="keyword">class</span>=<span class="string">"clear"</span> /&gt;或&lt;hr <span class="keyword">class</span>=<span class="string">"clear"</span> /&gt;</div></pre></td></tr></table></figure>
<p>来进行清理。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.news</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.clear</span> &#123;</div><div class="line">  <span class="attribute">clear</span>: both;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"news"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">img</span> src=<span class="string">"news-pic.jpg"</span> /&gt;</div><div class="line">&lt;p&gt;some text&lt;/p&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"clear"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><strong>优点：简单，代码少，浏览器兼容性好。</strong><br><strong>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</strong></p>
<p><strong>方法二：使用CSS的overflow属性</strong></p>
<p>  给浮动元素的容器添加<br>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">overflow</span>:hidden;</div></pre></td></tr></table></figure></p>
<p>  或<br>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">overflow</span>:<span class="keyword">auto</span>;</div></pre></td></tr></table></figure></p>
<p>  可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.<span class="class">news </span>&#123;</div><div class="line">  background-color: gray;</div><div class="line"><span class="symbol">  border:</span> solid <span class="number">1</span>px black;</div><div class="line"><span class="symbol">  overflow:</span> hidden;</div><div class="line">  *zoom: <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">.news <span class="class">img </span>&#123;</div><div class="line"><span class="symbol">  float:</span> left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">.news <span class="class">p </span>&#123;</div><div class="line"><span class="symbol">  float:</span> right;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="params">&lt;div class="news"&gt;</span></div><div class="line"><span class="params">&lt;img src="news-pic.jpg" /&gt;</span></div><div class="line"><span class="params">&lt;p&gt;</span>some text<span class="params">&lt;/p&gt;</span></div><div class="line"><span class="params">&lt;/div&gt;</span></div></pre></td></tr></table></figure>
<p><strong>方法三：给浮动的元素的容器添加浮动</strong></p>
<p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。</p>
<p><strong>方法四：使用邻接元素处理</strong></p>
<p>什么都不做，给浮动元素后面的元素添加clear属性。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.news</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: gray;</div><div class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">.<span class="attribute">content</span>&#123;</div><div class="line">  <span class="attribute">clear</span>:both;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"news"</span>&gt;</div><div class="line">&lt;<span class="selector-tag">img</span> src=<span class="string">"news-pic.jpg"</span> /&gt;</div><div class="line">&lt;p&gt;some text&lt;/p&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"content"</span>&gt;***&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>注意这里的div.content有内容。</p>
<p><strong>方法五：使用CSS的:after伪元素</strong></p>
<p>结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。<br>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">.<span class="class">news </span>&#123;</div><div class="line">  background-color: gray;</div><div class="line"><span class="symbol">  border:</span> solid <span class="number">1</span>px black;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">.news <span class="class">img </span>&#123;</div><div class="line"><span class="symbol">  float:</span> left;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">.news <span class="class">p </span>&#123;</div><div class="line"><span class="symbol">  float:</span> right;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">.clearfix:after&#123;</div><div class="line"><span class="symbol">  content:</span> <span class="string">"020"</span>;</div><div class="line"><span class="symbol">  display:</span> block;</div><div class="line"><span class="symbol">  height:</span> <span class="number">0</span>;</div><div class="line"><span class="symbol">  clear:</span> both;</div><div class="line"><span class="symbol">  visibility:</span> hidden;  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">.<span class="class">clearfix </span>&#123;</div><div class="line">  <span class="comment">/* 触发 hasLayout */</span></div><div class="line"><span class="symbol">  zoom:</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="params">&lt;div class="news clearfix"&gt;</span></div><div class="line"><span class="params">&lt;img src="news-pic.jpg" /&gt;</span></div><div class="line"><span class="params">&lt;p&gt;</span>some text<span class="params">&lt;/p&gt;</span></div><div class="line"><span class="params">&lt;/div&gt;</span></div></pre></td></tr></table></figure></p>
<p>通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p>
<ul>
<li><p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。</p>
</li>
<li><p>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。</p>
</li>
</ul>
<p>在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。</p>
<p>最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是CSS清除浮动？&quot;&gt;&lt;a href=&quot;#什么是CSS清除浮动？&quot; class=&quot;headerlink&quot; title=&quot;什么是CSS清除浮动？&quot;&gt;&lt;/a&gt;什么是CSS清除浮动？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>漫谈前端之路</title>
    <link href="http://damonare.github.io/2016/09/05/%E6%BC%AB%E8%B0%88%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/"/>
    <id>http://damonare.github.io/2016/09/05/漫谈前端之路/</id>
    <published>2016-09-05T15:55:48.526Z</published>
    <updated>2016-09-09T13:02:22.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前端之路何其漫漫~</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;说明：本篇文章原是写给学弟学妹的，但想来花的功夫确实不少，就把此篇文章当做自己的一个阶段性总结文章了，会保持长期更新。</p>
<a id="more"></a>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;总的来说HTML并不难，甚至可以说很无脑……HTML的标签个人觉得过一遍就得，知道什么时候该用什么标签就可以了，因为在以后的开发中打交道最多的就是各种各样的标签，想不熟都难。就像现在我写这篇文章用的Markdown一样，只是几个标签的反复应用。那么html的学习就相对来说很自由了，可以跟着w3school<a href="http://www.w3school.com.cn/html/index.asp" target="_blank" rel="external">W3school网址</a>过一遍标签，网上也有很多其它网站做这个的，像<a href="http://qctlr.cai.swufe.edu.cn/w3c/html/index.html" target="_blank" rel="external">菜鸟教程</a>,<a href="http://www.imooc.com/view/9" target="_blank" rel="external">慕课网视频</a>之类的都可以用,等熟练了就可以去国外看看一些前端的新技术，像<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">MDN</a>,<a href="http://www.w3schools.com/" target="_blank" rel="external">W3cschool(国际)</a>，<a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow(最大的程序员问答网站)</a>。</p>
<blockquote>
<p>HTML重点</p>
<ol>
<li>标签，span,div分清他们的特性，哪些是块级元素，哪些是行内元素;</li>
<li>语义化编程,HTML5的新元素的运用;</li>
<li>按照XHTML规范写代码,XHTML简单说是一种比HTML规范更加严格的HTML;</li>
<li>XML，这个和HTML实际上关系不大但长得很像，了解下即可，这是一种作为数据传输的文本形式，如今用的更多的是json传输数据，XML基本已经退出历史舞台了;</li>
</ol>
</blockquote>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一个网页，我们把它分为结构层（HTML），样式层（CSS），行为层（JavaScript）。这三门语言就构成了我们平常所见到的所有的网页。需要强调的是，包括手机端网页在内都逃脱不了这三门语言，只不过是无数的前辈为了让后来人写代码更自由一点，更爽一点，自己封装了很多函数供我们调用。比如HTML ，CSS比较有名的框架<a href="http://www.bootcss.com/" target="_blank" rel="external">Bootstrap</a>,JavaScript的<a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>。Bootstrap是Twitter员工设计的现在整个github上star数最多的估计就是bootstrap了，截止改动日期已经达到了96802,相信过不了多久就会突破十万了！bootstrap呢，有人说这是专门为后端设计的框架，因为它运用起来十分的简单，将文件引入后，知道它的定义效果是什么样的就能很熟练的运用，而且支持移动端，响应式布局做的很好，这是它受欢迎的很大一部分原因~关于jquery,JQuery是继prototype之后又一个优秀的Javascript库。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+）,jQuery是免费、开源的，使用MIT许可协议。jQuery的语法设计可以使开发更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。设计理念就是写更少的代码做更多的事，因此这个库用起来还是很爽的，但同样也导致很多人会用jQuery实现某个功能却不知道原生js如何实现，个人觉得原生js还是要学深的，毕竟框架和库总是在改变，但核心——JavaScript是不会变的。<br>&nbsp;&nbsp;&nbsp;&nbsp;那么CSS该如何学习呢，就一个字，敲！等你把CSS所有的坑都踩过一遍之后，CSS也就彻底出师了。在CSS3出来之前CSS就是一个纯粹的样式表，想要什么样式，直接设置就OK，但随着CSS3的推出，整个CSS好像就被打了鸡血一样，焕发着活力。因为在一定程度上它把JavaScript的活给抢了，比如简单动画，对鼠标事件的某些触发等等，很多人说CSS是其实是设计师的工具，因为他没有变量也没有条件语句，纯粹的罗列代码，很多程序员都觉得写CSS很痛苦，事实上也的确如此，所以有了sass和less等CSS预处理器，这个让CSS写起来变得爽多了~另外，CSS3的动画也是很值得研究的。</p>
<blockquote>
<p>CSS重点</p>
<ol>
<li>明白什么是块级元素，什么是内联元素；块级元素（div, form，h1-h6,hr,p等），内联元素（span,b,a,i,img）；</li>
<li>id和class选择器的理解；</li>
<li>div和CSS的配合（包括叠加，定位和浮动）；</li>
<li>布局，普通，自适应，响应式，流式等布局（一点点理解吧）；</li>
<li>对于这张图的理解；<img src="https://segmentfault.com/img/bVtlKv" alt="明白这张图">；</li>
<li><a href="http://www.1024i.com/demo/less/" target="_blank" rel="external">less</a>和<a href="http://sass.bootcss.com/docs/sass-reference/" target="_blank" rel="external">sass</a>的学习；</li>
<li>bootstrap学习;</li>
<li>CSS3动画 @keyframes;</li>
</ol>
</blockquote>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;首先我想让大家明白的是，这门语言很好入门，况且是在大家学了一学期C语言的前提下，但同样要明白的是作为一门编程语言，想要精通这门语言绝不是一两月那么简单的。在浏览器里面有一个叫JS引擎的东西，它是用C++写出来的，而它的作用就是渲染JavaScript代码，说的通俗点，就是让浏览器知道我们所写出来的JavaScript应该如何解析。Chrome之所以让人感觉快就是因为它自己有一个牛逼的V8引擎，这是其它四个浏览器（IE，Firefox,Opera,Safari）所没有的，这个V8引擎不论解析JavaScript还是Jquery都特别的吊，所以呈现页面也就特别的快。这里需要说一下的是，浏览器解析一个网页的顺序大体上是这样的：先加载HTML标签组成DOM树（不知道DOM是啥不要紧，学完数据结构就明白了），遇到link,script然后加载相关的CSS或是JavaScript代码，这也是为什么一般script标签写在body之后的原因，因为一旦相关的DOM没有加载完而JavaScript需要对它有操作，那浏览器就要懵逼了。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果说HTML和CSS给网页穿上了一件衣服的话，那么JavaScript就是在构造网页的五脏六腑了。我们在编写代码的时候一定要记住我们是在和浏览器说话，是在和浏览器交流，你要让浏览器明白你想要呈现出的效果是什么，不然你让它猜（它的确会猜，这也是HTML代码比较自由的原因，不过还是推荐大家按照XHTML的要求写代码）,浏览器会感觉很操蛋的，那这个交流就很不成功，即使呈现出了想要的页面，以后想要优化的话就比较费力了。<br>&nbsp;&nbsp;&nbsp;&nbsp;附上几个学习地址：<a href="http://www.imooc.com/view/36" target="_blank" rel="external">慕课网视频</a>；<a href="http://www.w3school.com.cn/js/" target="_blank" rel="external">W3School</a>；我这里还有极客学院的视频有要的可以找我拷。给大家总结下JavaScript的重点吧：</p>
<blockquote>
<ol>
<li>如果你认为JS就是操作DOM树，弹出个警告框那么简单的话就错了，一定要抱着谦虚的态度去学（学完HTML，CSS很容易让人产生JavaScript也很简单的错觉），当然它并没有C++那么逆天，好好学还是很容易出成绩的。</li>
<li>表单验证，对于表单的提交，容错性的考虑；</li>
<li>网页特效，比如我们经常看到的图片轮播，菜单导航（有一部分是纯粹的CSS代码写的）等；</li>
<li>数据传输，通过Ajax我们可以在不刷新网页的前提下更新网页的部分元素哦，而且通过对于数据的操作，我们可以实现诸如瀑布流，数据交换等功能。这点可以参考QQ空间网页版看好友动态，只要你往下一直翻，就有结果呈现出来。以前我们数据传输的形式是直接把php代码写在HTML文件中，但AJAX的出现打破了这一僵局，使得前后端分离的更为彻底，因为只需要一个接口，前后端定下接口也就各干各事了。</li>
<li>事件触发（鼠标点击，键盘），开发WebAPP的话得考虑手机系统API的调用，和鼠标键盘时间就不一样的了，前端的API实际上只有14w+但webapp光安卓的API就有40w+,所以webapp是个大坑，在它还没法超越原生性能之前还是不要触碰的好~；</li>
<li>OOP,jaascript没有传统的类的概念，所以它的很多东西实际上都是特立独行的一套，但OOP思想才是javascript的精髓，前面操作个DOM树，页面优化啥的实际上并没有多少技术含量;刚开始可能会无从下手，相信我，每个人都是这样。先从一个小demo写起来,起码{}得有啊;</li>
<li>json，接触了OOP,学会了AJAX那么现在就得学下json了，json是一种数据格式，在页面交互中,后端会把数据以json格式返回，前端用ajax拿到后，把这个字符串进行相应的解析,从而得到我们需要的数据。到了这一步，你就可以出去找项目了，只有实践才能不断提高自己；</li>
<li>闭包，这个后期很重要，也是javascript的一大特色，简单的说，闭包就是实现了在函数外调用函数内定义的局部变量的功能；</li>
<li>原型链和继承，这是个很抽象的东西，但很有用处的东西，一定要深入看才行，真的，不然真的看不懂…找个角落，带上耳机，看看闭包原型链何尝不是一种乐趣呢~;</li>
<li>库和框架的学习，近几年jquery不是很受待见了，这倒不是说jquery不值得学了,只是新技术层出不穷，使得jquery的优势不再明显，这实际上是个好事，一方面说明技术不断进步，另一方面也说明前端始终散发着活力。最近几年angularjs,react，Vue都是比较火的框架，有机会可以看看，你会发现写前端顿时变成了一件享受的事情，国内的框架还有dcloud,apicloud等等,这俩国人设计出来主要的方向是webapp，所以想做app的童鞋也可以尝试下，感受下一次开发多平台调用的快感~关于webapp有兴趣的可以了解下，这里按下不表。框架建议学完jquery再看;</li>
<li>webpack,grunt,gulp等前端构建工具的学习和使用;</li>
<li>ECMAscript6学习<a href="http://www.ruanyifeng.com/blog/2014/04/ecmascript_6_primer.html" target="_blank" rel="external">阮一峰的日志</a>;</li>
<li>Nodejs学习;</li>
</ol>
</blockquote>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;现在的前端并不是纯粹的前端，绝大数都已经叛变了！我们口口声声宣称着要实现前后端分离（实际上这才是开发的终极目标），但在实际开发中往往不能分离，所以基本每一个前端都会学一门后台语言，比较热门的后台语言有：PHP，Java，Python，Node；PHP运用的最为广泛，Java适合开发大型网站（什么是大型网站呢，就类似于淘宝那种满天的图片数据那种），现在世界上80%网站还是用的PHP的，所以PHP尽量了解下（这估计是你们下学期考虑的事了），Node就是js(和js的语法啥的一毛一样)，不过它多了一个模块，弥补了js的缺陷，关于模块….不知道你们理解不理解，像java有类文件，Python有import机制，PHP有require和include。现在不懂Node的前端是很尴尬的，所以以后有机会也要了解下的。Node我也还在学习中,按下不表;</p>
<blockquote>
<p>后端重点</p>
<ol>
<li>PHP语法简单的了解;</li>
<li>PHP框架了解CI,thinkphp,laravel等等;</li>
<li>SQL语句学习，这个必备，虽然现在的数据库工具十分的强大，但必要的SQL语句还得懂要不怎么用PHP代码操作数据库呢~;</li>
<li>Node学习，Node发展实在太快，醉的不行，现在都6.2.0版本了~;</li>
<li>PHP7.0语法了解，这个具体的不太清楚,听那些后端说加了很多新的特性~;</li>
<li>其它语言推荐，也可以尝试下Java写后端的感觉，试试Python，Python在写爬虫和数据处理上效率还是很给劲的~</li>
</ol>
</blockquote>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Photoshop,身为前端工程师Photoshop肯定是要掌握的因为很多时候设计师给的图并不是切好的，我们主要自己切图，于是乎，切图也就成了我们的必备技能，切图仔的戏称由此而来。另外，会点Photoshop也可以给自己PP图，装装逼嘛~<br>&nbsp;&nbsp;&nbsp;&nbsp;很多人觉得前端工程师不需要懂算法，但事实却是各大公司的面试题里都会多多少少有算法题，这门学问很深，倒也不必深入研究，术业有专攻，能把前端一层搞好就不错了，切记眼高手低~，一些比较基础经典的算法，比如快速排序算法，堆排序算法，归并排序，选择排序算法，深度优先，广度优先…等等等，试着用javascript敲一遍成就感还是很大大滴有的~~~;<br>&nbsp;&nbsp;&nbsp;&nbsp;数据结构~有算法也就有数据结构咯~栈，队列等线性表，树，图;come on,baby!<br>&nbsp;&nbsp;&nbsp;&nbsp;网络协议，我们知道OSI七层协议：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层；我们所做的都是在这层皮肤上（应用层）,接触最多的就是是HTTP协议了，协议这个玩意看不见摸不着的，很抽象，我们可以用一些抓包工具抓包像Wireshark,Fiddler等抓包工具,可以很方便抓取数据，其中wireshark各种协议通吃，也是国际上认可度很高的一款抓包工具，Fiddler一般开发者用的比较多，它可以抓取HTTPS协议，而且对于前端后端交互的数据有很好的处理，深受前端开发者的喜爱~。协议这东西看起来很无用，似乎黑客用的比较多一点~但这玩意有个好处——稳定啊，不会变，整个世界都在用的就是TCP/IP，学习成本低，也不会贬值，何不拿来耍耍~另外，很多公司面试都会问本机和服务器建立连接时的三次握手具体都发生了什么~所以协议这块还是很有必要学的；<br>&nbsp;&nbsp;&nbsp;&nbsp;操作系统…以我现在的水平说不出来…没学过，不过起码得熟悉window，Linux,Mac系统的操作吧(好像还是啥都没说，留着以后补充吧);</p>
<h2 id="前端工具"><a href="#前端工具" class="headerlink" title="前端工具"></a>前端工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个前端开发者，要有适合自己的工具做开发使用，那么使用IDE还文本是编辑器，我在这里就不给建议了，刚开始的个人倾向还是文本编辑器，因为不同于其它语言，HTML有点像语言学科，需要记，使用IDE的话不太利于记忆标签。IDE的话推荐WebStorm和atom(我现在再用)，国内有一款Hbuilder（可开发webapp，配合mui,html5plus,dcloud），我用过一段时间…..很蛋疼的IDE，界面设计的很不错，也还好用，也一直在我电脑里，但不写APP的话是不会打开的….像VS,Dreamweaver之流可以体验，要是你骨骼惊奇觉得好用也可以用….并不强求；文本编辑器呢，那不用说肯定Sublime，Sublime强大的插件支持让它如虎添翼，用着用着就会发现，实际上在插件的支持下它本身就是一个IDE，但却没有IDE启动缓慢的诟病。刚开始可以各种工具（notepad++，UEditor，Vim等等）都试一下，不过我相信最后你还是会回到Sublime的怀抱的（如果你觉得Sublime不好用，那只能说明你还不会用它）。附上学习地址：<a href="http://www.imooc.com/view/40" target="_blank" rel="external">慕课视频</a>，<a href="http://www.imjeff.cn/blog/2313/" target="_blank" rel="external">Sublime相关博客</a>；安装的话网上教程多得是，自己百一下就行。<br>&nbsp;&nbsp;&nbsp;&nbsp;说完了开发工具，再来说下调试工具，调试工具的话，Firefox有一个 插件叫Firebug很好用，也可以使用浏览器自带的开发者工具（按F12就出来了，console的使用，XHR的使用，断点调试，基本已经足够日常开发了），如果要对网页某个元素进行操作或是了解就把鼠标放到元素下面，右键检查就OK。或是直接点击左上角的箭头移动鼠标到要检查的元素上面。调试很重要，前端前辈们在很长一段时间里调试JavaScript纯粹靠运气。所以我们是很幸运的。</p>
<h2 id="日常学习"><a href="#日常学习" class="headerlink" title="日常学习"></a>日常学习</h2><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;《JavaScript高级程序设计》《JavaScript权威指南》如果你要走前端这两本书是必买的，甚至整个职业生涯有这两本书就足够了，尤其是高程深入浅出很适合新手学习。<br>&nbsp;&nbsp;&nbsp;&nbsp;《JavaScript DOM编程艺术》很通俗，适合入门；<br>&nbsp;&nbsp;&nbsp;&nbsp;《锋利的jquery》jquery入门书；<br>&nbsp;&nbsp;&nbsp;&nbsp;《PHP和MySQL web开发》这本是很多人PHP的入门书籍，经典程度不亚于高程；<br>&nbsp;&nbsp;&nbsp;&nbsp;《深入浅出nodeJS》国内最好的nodejs书籍，淘宝在职大牛朴灵著作，但这本不适合入门…入门的话推荐看下面这本<br>&nbsp;&nbsp;&nbsp;&nbsp;《Nodejs开发指南》郭家宝著作;<br>&nbsp;&nbsp;&nbsp;&nbsp;《图解HTTP》通过漫画的形式讲解HTTP协议，很通俗易懂，小日本的这本书的确不错哦~<br>&nbsp;&nbsp;&nbsp;&nbsp;《HTTP权威指南》HTTP权威书籍，O’REILLY出品必属精品~条件好的话真心推荐把O’REILLY出版的前端方面的书都买来看看;</p>
<h3 id="自媒体平台推荐"><a href="#自媒体平台推荐" class="headerlink" title="自媒体平台推荐"></a>自媒体平台推荐</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个程序员，我们逛的网站肯定就有偏向性咯，要说程序员聚集地肯定是Github(感兴趣的可以了解下，这里按下不表)，国内网站做的比较好的博客平台有<a href="http://www.csdn.net/" target="_blank" rel="external">CSDN</a>，<a href="http://www.cnblogs.com/" target="_blank" rel="external">博客园</a>，<a href="https://segmentfault.com" target="_blank" rel="external">Segmentfault</a>，<a href="http://www.v2ex.com/" target="_blank" rel="external">V2EX</a>,<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a>，<a href="http://gold.xitu.io/explore/frontend" target="_blank" rel="external">掘金</a>等等，经常逛逛这些网站看看大牛们的博客也是很有好处的。当然像<a href="http://www.zhihu.com/" target="_blank" rel="external">知乎</a>，<a href="http://toutiao.com/" target="_blank" rel="external">今日头条</a>等类似自媒体平台，想学也是有很多文章可以看得。<strong>微信订阅号推荐：优秀网页设计，前端开发，Web开发，差评（这个主要是增长点Web之外的互联网知识），前端大全</strong>。<strong>微博账号推荐：IT程序猿，优秀网页设计，酷勤网-程序员的那点事</strong>。大家有好的媒体平台记得分享给我啊，嘿嘿。</p>
<h3 id="前端大牛-团队推荐"><a href="#前端大牛-团队推荐" class="headerlink" title="前端大牛/团队推荐"></a>前端大牛/团队推荐</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前端的世界变化快，但也正因为此涌现出了一批大牛，他们对新技术的学习乐此不疲，常常自发的翻译新技术文章，解释新技术要点，成为新技术的布道者。<a href="http://www.zhangxinxu.com/" target="_blank" rel="external">张鑫旭</a>,<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="external">阮一峰</a>，<a href="http://www.aoao.org.cn/" target="_blank" rel="external">嗷嗷</a>，<a href="http://www.welefen.com/" target="_blank" rel="external">李成银</a>，<a href="http://jayli.github.io/" target="_blank" rel="external">拔持</a>，<a href="http://www.cnblogs.com/Darren_code/" target="_blank" rel="external">聂微东</a>，<a href="http://jiongks.name/" target="_blank" rel="external">囧克斯</a>，<a href="http://justjavac.com/" target="_blank" rel="external">justjavac</a>…..还有一些牛×的前端团队,<a href="http://www.75team.com/" target="_blank" rel="external">360的奇舞团</a>，<a href="http://fex.baidu.com/" target="_blank" rel="external">百度FEX</a>，<a href="http://www.taobaofed.org/" target="_blank" rel="external">淘宝FED</a>,<a href="http://www.alloyteam.com/" target="_blank" rel="external">腾讯的alloy</a>……这些基本就是国内前端技术的最前沿了，想学新技术或是想把一个点挖深可以多关注下这些站点~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前端之路何其漫漫~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;说明：本篇文章原是写给学弟学妹的，但想来花的功夫确实不少，就把此篇文章当做自己的一个阶段性总结文章了，会保持长期更新。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://damonare.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端构建工具" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>从隐藏元素谈起</title>
    <link href="http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/"/>
    <id>http://damonare.github.io/2016/09/05/从隐藏元素谈起/</id>
    <published>2016-09-05T13:54:57.873Z</published>
    <updated>2016-09-10T15:33:43.960Z</updated>
    
    <content type="html"><![CDATA[<p><strong>念念不忘,必有回响,有一口气,点一盏灯。</strong></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;说起隐藏元素我想每一个前端er都能说起几种，但能说全的我想就不是很多了。博主总结了几种隐藏元素的方法，总结如下：</p>
<blockquote>
<p>overflow:hidden<br>opacity:0；<br>visibility:hidden<br>display:none<br>position:absolute<br>clip(clip-path):rect()/inset()/polygon()<br>z-index:-1000</p>
</blockquote>
<p><strong>我们为什么会需要这么多隐藏元素的方法呢，而且他们看起来实现的都是同样的效果。其实每一种方法实际上都有一些细微的不同，这些不同决定了在一些特定场合下使用哪一种方法。我们下面细细探讨下这些细微之处.</strong></p>
<a id="more"></a>
<h3 id="1-overflow"><a href="#1-overflow" class="headerlink" title="1. overflow"></a>1. overflow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	 <span class="attribute">overflow</span>:hidden; <span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>overflow的hidden用来隐藏元素溢出部分，占据空间，无法响应点击事件。</strong></p>
<h3 id="2-opacity"><a href="#2-opacity" class="headerlink" title="2.opacity"></a>2.opacity</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">opacity</span>:<span class="number">0</span>;<span class="comment">/* 占据空间，可以点击 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.hide_2</span>&#123;</div><div class="line">	<span class="attribute">-webkit-filter</span>:<span class="built_in">opacity</span>(0);</div><div class="line">	<span class="attribute">filter</span>:<span class="built_in">opacity</span>(0);<span class="comment">/* 占据空间，可以点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>过滤元素filter也可使用opacity值设置透明度，不过filter现在的兼容性不好，只支持webkit内核，这里顺带一提。</p>
</blockquote>
<p><strong>opacity是用来设置元素透明度的，但当设置成0的时候也就相当于隐藏元素了。因此，元素依然存在原来的位置，占据空间也可响应事件。如果你打算使用 opacity 属性在读屏软件中隐藏元素，很不幸，你并不能如愿。元素和它所有的内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致。</strong></p>
<h3 id="3-visibility"><a href="#3-visibility" class="headerlink" title="3.visibility"></a>3.visibility</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">visibility</span>:hidden; <span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如同 opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏</strong></p>
<h3 id="4-display"><a href="#4-display" class="headerlink" title="4.display"></a>4.display</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">display</span>:none;<span class="comment">/* 不占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>经典的display隐藏元素,这个是彻底的隐藏了元素，不占据空间，也就不影响布局，当然也无法响应事件。</strong></p>
<h3 id="5-position"><a href="#5-position" class="headerlink" title="5.position"></a>5.position</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">position</span>：absolute;</div><div class="line">	<span class="attribute">left</span>:-<span class="number">99999px</span>;</div><div class="line">	<span class="attribute">top</span>:-<span class="number">90999px</span>;<span class="comment">/* 不占据空间，无法点击 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.hide</span>——2&#123;</div><div class="line">	<span class="attribute">position</span>：relative;</div><div class="line">	<span class="attribute">left</span>:-<span class="number">99999px</span>;</div><div class="line">	<span class="attribute">top</span>:-<span class="number">90999px</span>;<span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互——译者注）。在这种情况下，你只能考虑将元素移出可视区域。这个办法既不会影响布局，有能让元素保持可以操作。下采用这种办法未尝不可 </strong></p>
<h3 id="6-clip-clip-path"><a href="#6-clip-clip-path" class="headerlink" title="6.clip/clip-path"></a>6.clip/clip-path</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">    <span class="attribute">position</span>:absolute;<span class="comment">/*fixed*/</span></div><div class="line">	<span class="attribute">clip</span>:<span class="built_in">rect</span>(top,right,bottom,left);<span class="comment">/* 占据空间，无法点击 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.hide_2</span> &#123;</div><div class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(0px 0px,0px 0px,0px 0px,0px 0px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>隐藏元素的另一种方法是通过剪裁它们来实现。在以前，这可以通过 clip 属性来实现，但是这个属性被废弃了(现在浏览器依然支持)，换成一个更好的属性叫做 clip-path。clip-path属性实在是用处大大滴有，可以很容易的实现一些复杂的图形<a href="http://species-in-pieces.com/#" target="_blank" rel="external">大漠老师分享的一个链接</a>，该链接里的图形大多都是用clip-path的polygon值来实现的。但可惜的是依旧只能在chrome40+浏览器里使用.</strong></p>
<h3 id="7-z-index"><a href="#7-z-index" class="headerlink" title="7.z-index"></a>7.z-index</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.hide</span>&#123;</div><div class="line">	<span class="attribute">position</span>:absolute;</div><div class="line">	<span class="attribute">z-index</span>:-<span class="number">1000</span>;<span class="comment">/* 不占据空间，无法点击 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>通过设置z-index值使其它元素遮盖该元素也算是一种隐藏了。</strong></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>在这篇教程里，我们看了 7 种不同的通过 CSS 隐藏元素的方法。每一种方法都与其他几种有一点区别。知道你想要实现什么有助于你决定采用哪一个属性，随着时间推移，你就能根据实际需求本能地选择最佳方式了。如果你对于隐藏元素的这些方法还有任何问题，请在评论中留言。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;念念不忘,必有回响,有一口气,点一盏灯。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;说起隐藏元素我想每一个前端er都能说起几种，但能说全的我想就不是很多了。博主总结了几种隐藏元素的方法，总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;overflow:hidden&lt;br&gt;opacity:0；&lt;br&gt;visibility:hidden&lt;br&gt;display:none&lt;br&gt;position:absolute&lt;br&gt;clip(clip-path):rect()/inset()/polygon()&lt;br&gt;z-index:-1000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我们为什么会需要这么多隐藏元素的方法呢，而且他们看起来实现的都是同样的效果。其实每一种方法实际上都有一些细微的不同，这些不同决定了在一些特定场合下使用哪一种方法。我们下面细细探讨下这些细微之处.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>网络协议分析</title>
    <link href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <id>http://damonare.github.io/2016/09/05/网络协议分析/</id>
    <published>2016-09-05T13:51:41.613Z</published>
    <updated>2016-09-06T04:06:13.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络协议分析</strong></p>
<h1 id="1-基于Fiddler的HTTP-HTTPS协议分析"><a href="#1-基于Fiddler的HTTP-HTTPS协议分析" class="headerlink" title="1.基于Fiddler的HTTP/HTTPS协议分析"></a>1.基于Fiddler的HTTP/HTTPS协议分析</h1><p><strong>关于Fiddler：</strong> Fiddler是一款由C#开发的免费http调试代理软件，有.net 2和.net 4两种版本。Fiddler能够记录所有的电脑和互联网之间的http通讯，Fiddler 可以也可以检查所有的http通讯，设置断点，以及Fiddle 所有的”进出”的数据。</p>
<a id="more"></a>
<p> <strong>优点：</strong></p>
<blockquote>
<p><strong>a</strong>.Firebug虽然可以抓包，但是对于分析http请求的详细信息，不够强大。模拟http请求的功能也不够，且firebug常常是需要”无刷新修改”，如果刷新了页面，所有的修改都不会保存； <strong>b</strong>.Wireshark是通用的抓包工具，但是比较庞大，对于只需要抓取http请求的应用来说，似乎有些大材小用。且Wireshark无法解密HTTPS故而选择使用fiddler来对HTTP协议进行分析； <strong>c</strong>.Httpwatch也是比较常用的http抓包工具，但是只支持IE和firefox浏览器（其他浏览器可能会有相应的插件），对于想要调试chrome浏览器的http请求，似乎稍显无力，而Fiddler2 是一个使用本地 127.0.0.1:8888 的 HTTP 代理，任何能够设置 HTTP 代理为 127.0.0.1:8888 的浏览器和应用程序都可以使用 Fiddler。</p>
</blockquote>
<p>这里为体现个人特色，选择在本地服务器运行观察抓包结果，如图： <img src="https://segmentfault.com/img/bVyLGj" alt="图片描述"></p>
<p>实际上，Wireshark抓不到本地服务器发送报文，这也是Fiddler更利于开发调试的原因之一。 HTTP协议分析（1）：由于之前本地测试过，所以第一次抓到的包返回的状态码是304，清除缓存后变为正常的200，图中我们可以看到返回的数据：”谭继臻FiddlerHTTP协议测试”，这里我们通过请求头报文可以看到请求站点（localhost:81）,请求方式（XMLHttpReQuest）等信息。由于Fiddler只能抓到HTTP/HTTPS的包，关于HTTP协议的深入分析我们使用Wireshark进行。、</p>
<h1 id="2-基于Wireshark的TCP-HTTP协议深入分析"><a href="#2-基于Wireshark的TCP-HTTP协议深入分析" class="headerlink" title="2.基于Wireshark的TCP/HTTP协议深入分析"></a>2.基于Wireshark的TCP/HTTP协议深入分析</h1><p><strong>关于Wireshark：</strong> Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。 优点：</p>
<blockquote>
<p><strong>a</strong>.使用操作非常简单，对于初级和中级网络学习者来说是一款完美的抓包软件。</p>
<p><strong>b</strong>.有很多小工具和小技巧可以帮助我们更快更好的了解网络，例如filter，expression，statistics等等。</p>
<p><strong>c</strong>.界面设计很简洁，给使用者一种非常清新的感觉。</p>
<p><strong>d</strong>.与Fiddler相比可抓取的包更广，更多，并且软件开源，用着放心。</p>
</blockquote>
<p><strong>实例分析TCP三次握手过程：</strong></p>
<p>这里我们打开哔哩哔哩网站首页观察抓包情况（<a href="http://www.bilibili.com/）；" target="_blank" rel="external">http://www.bilibili.com/）；</a></p>
<ul>
<li>第一次握手数据包</li>
</ul>
<p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。如下图： <img src="https://segmentfault.com/img/bVyLHK" alt="第一次握手"></p>
<ul>
<li>第二次握手的数据包</li>
</ul>
<p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1=1, 如下图： <img src="https://segmentfault.com/img/bVyLHQ" alt="第二次握手"></p>
<ul>
<li>第三次握手的数据包</li>
</ul>
<p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1,如下图： <img src="https://segmentfault.com/img/bVyLH3" alt="第三次握手"></p>
<p>就这样通过了TCP三次握手，建立了连接,三次握手基本结束，开始真正的数据传送阶段： 建立了三次握手后，我们就开始利用这个链接来传送信息了。下面我们看看经过三次握手后的第四个TCP报文段。这是服务器返回来的报文段： <img src="https://segmentfault.com/img/bVyLH8" alt="图片描述"></p>
<p>我们惊奇的发现服务器返回了ack=557，即请求第557Byte的数据，而这557Bytes是什么时候发出去的呢，我们想到了在第三次握手的时候，客户端发送的TCP是能够携带数据的。怎么验证是否携带了557Bytes数据呢，我们想到了HTTP协议封装的报文，我们来验证一下是否是557Bytes，打开HTTP协议如下:</p>
<p><img src="https://segmentfault.com/img/bVyLIL" alt="图片描述"></p>
<p>我们看到，HTTP协议封装的报文，长度为Bytes in flight：556。表示已经发送了557Bytes，所以，服务器理应返回一个ack=554的确认，以表示接收到了556Bytes以前的数据，希望接受557bytes以及以后的数据。而上面的第四个报文也正是这么做的。 服务端返回了ack=557之后，服务端没有继续停下，而是继续向客户端发送了两个报文段。我们来看下第五、六个报文段:</p>
<p><img src="https://segmentfault.com/img/bVyLIO" alt="图片描述"></p>
<p>第五个报文段发送了seq=557，ack=1203告诉服务端，请求你的1203数据，我这是第557个数据。发完后服务端又发送了第六个报文，如下:</p>
<p><img src="https://segmentfault.com/img/bVyLIR" alt="图片描述"></p>
<p>服务端发送了seq=1113，ack=2400，这表示：我请求第2400Bytes，这是我的第1113Bytes,这个报文之后，服务端会继续给客户端传送数据，这里就不一一列出了。</p>
<p>断开连接： 断开连接时，要发送FIN=1，并且对方要回复ACK=1。我们来看下截取的报文段。</p>
<p><img src="https://segmentfault.com/img/bVyLIV" alt="图片描述"></p>
<p>我们看到FIN=1。</p>
<p><img src="https://segmentfault.com/img/bVyLI1" alt="图片描述"></p>
<p>返回了ACK=1，结束连接。</p>
<p>到这里HTTP协议就算分析结束了，我们可以看到HTTP传输数据确实是靠TCP协议来完成的，由于哔哩哔哩网站内容很多，所以看起来很乱…这点没有考虑周全。</p>
<h1 id="3-使用Wireshark分析ARP协议"><a href="#3-使用Wireshark分析ARP协议" class="headerlink" title="3.使用Wireshark分析ARP协议"></a>3.使用Wireshark分析ARP协议</h1><p>在显示筛选编辑框中输入”arp”，回车，分组列表窗口将只显示ARP消息。点击第一行查看具体数据：</p>
<p><img src="https://segmentfault.com/img/bVyLI9" alt="图片描述"></p>
<blockquote>
<p>可以看出硬件类型（hardware type）是以太网（1），协议类型（protocol type）为0x0800，表示使用ARP的协议类型为IPV4。硬件地址长度（hardware size）为6。协议地址长度（protocol size）为4。 发送方硬件地址（sender MAC address）：bc:30:7d:97:c8:08 发送方协议地址（Sender IP address）：192.168.1.5 目的硬件地址（target MAC address）为00:00:00:00:00:00，表示是广播地址。 目的协议地址（target IP address）为192.168.1.1，定义目的设备的协议地址。</p>
</blockquote>
<h1 id="4-使用Wireshark分析ICMP协议"><a href="#4-使用Wireshark分析ICMP协议" class="headerlink" title="4.使用Wireshark分析ICMP协议"></a>4.使用Wireshark分析ICMP协议</h1><p>在cmder(也可以是一般的命令行窗口)中以www.damonare.cn(个人网站)为目标主机，在命令行窗口执行Ping命令，要求ping通10次；</p>
<p><img src="https://segmentfault.com/img/bVyLJe" alt="图片描述"></p>
<p>停止截获报文，抓包结果:（只显示ping的数据包） 在显示筛选编辑框中输入”icmpv6”，回车，分组列表窗口将只显示icmp消息。点击第一行查看具体数据：</p>
<p><img src="https://segmentfault.com/img/bVyLJi" alt="图片描述"></p>
<h1 id="5-使用Wireshark分析IP协议"><a href="#5-使用Wireshark分析IP协议" class="headerlink" title="5.使用Wireshark分析IP协议"></a>5.使用Wireshark分析IP协议</h1><p>在显示筛选编辑框中输入”ip”，回车，分组列表窗口将只显示IP消息。选取一个有IP协议的数据报：</p>
<p><img src="https://segmentfault.com/img/bVyLJj" alt="图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;网络协议分析&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-基于Fiddler的HTTP-HTTPS协议分析&quot;&gt;&lt;a href=&quot;#1-基于Fiddler的HTTP-HTTPS协议分析&quot; class=&quot;headerlink&quot; title=&quot;1.基于Fiddler的HTTP/HTTPS协议分析&quot;&gt;&lt;/a&gt;1.基于Fiddler的HTTP/HTTPS协议分析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;关于Fiddler：&lt;/strong&gt; Fiddler是一款由C#开发的免费http调试代理软件，有.net 2和.net 4两种版本。Fiddler能够记录所有的电脑和互联网之间的http通讯，Fiddler 可以也可以检查所有的http通讯，设置断点，以及Fiddle 所有的”进出”的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="http" scheme="http://damonare.github.io/tags/http/"/>
    
      <category term="网络协议" scheme="http://damonare.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="http://damonare.github.io/2016/09/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/"/>
    <id>http://damonare.github.io/2016/09/05/前端面试大全/</id>
    <published>2016-09-05T13:10:55.167Z</published>
    <updated>2016-09-22T16:00:51.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML面试题"><a href="#HTML面试题" class="headerlink" title="HTML面试题"></a>HTML面试题<br><br></h3><ol>
<li>XHTML和HTML有什么区别<blockquote>
<ul>
<li>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言<br>最主要的不同：</li>
<li>XHTML 元素必须被正确地嵌套。</li>
<li>XHTML 元素必须被关闭。</li>
<li>标签名必须用小写字母。</li>
<li>XHTML 文档必须拥有根元素。</li>
</ul>
</blockquote>
</li>
</ol>
<a id="more"></a>
<p>2.前端页面有哪三层构成，分别是什么?作用是什么?</p>
<blockquote>
<ul>
<li>结构层 Html 表示层 CSS 行为层 js;</li>
</ul>
</blockquote>
<p>3.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</p>
<blockquote>
<ul>
<li>Ie(Ie内核) 火狐（Gecko） 谷歌（webkit,Blink） opera(Presto),Safari(wbkit)</li>
</ul>
</blockquote>
<p>4.什么是语义化的HTML?</p>
<blockquote>
<ul>
<li>直观的认识标签 对于搜索引擎的抓取有好处，用正确的标签做正确的事情！</li>
<li>html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ul>
</blockquote>
<p>5.HTML5 为什么只需要写 !DOCTYPE HTML？</p>
<blockquote>
<ul>
<li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</li>
</ul>
</blockquote>
<p>6.Doctype作用？标准模式与兼容模式各有什么区别?</p>
<blockquote>
<ul>
<li>!DOCTYPE声明位于位于HTML文档中的第一行，处于html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</li>
<li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
</blockquote>
<p>7.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和<br>HTML5？</p>
<blockquote>
<ul>
<li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li>
<li>绘画 canvas</li>
<li>用于媒介回放的 video 和 audio 元素</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websockt, Geolocation<br>移除的元素</li>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；<br>支持HTML5新标签：</li>
<li>IE8/IE7/IE6支持通过document.createElement方法产生的标签，</li>
<li>可以利用这一特性让这些浏览器支持HTML5新标签，</li>
<li>浏览器支持新标签后，还需要添加标签默认的样式：</li>
</ul>
</blockquote>
<p>8.请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p>
<blockquote>
<ul>
<li>cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会</li>
<li>sessionStorage和localStorage的存储空间更大；</li>
<li>sessionStorage和localStorage有更多丰富易用的接口；</li>
<li>sessionStorage和localStorage各自独立的存储空间；</li>
</ul>
</blockquote>
<p>9.如何实现浏览器内多个标签页之间的通信?</p>
<blockquote>
<ul>
<li>调用localstorge、cookies等本地存储方式</li>
</ul>
</blockquote>
<h3 id="CSS面试题"><a href="#CSS面试题" class="headerlink" title="CSS面试题"></a>CSS面试题<br><br></h3><p> 1.简要说一下CSS的元素分类</p>
<blockquote>
<ul>
<li>块级元素：div,p,h1,form,ul,li;</li>
<li>行内元素 :  span&gt;,a,label,input,img,strong,em;</li>
</ul>
</blockquote>
<p> 2.CSS隐藏元素的几种方法（至少说出三种）</p>
<blockquote>
<ul>
<li>Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;</li>
<li>Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;</li>
<li>Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;</li>
<li>Position:不会影响布局，能让元素保持可以操作;</li>
<li>Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低;</li>
</ul>
</blockquote>
<p> 3.CSS清除浮动的几种方法（至少两种）</p>
<blockquote>
<ul>
<li>使用带clear属性的空元素</li>
<li>使用CSS的overflow属性；</li>
<li>使用CSS的:after伪元素；</li>
<li>使用邻接元素处理；</li>
</ul>
</blockquote>
<p> 4.CSS居中（包括水平居中和垂直居中）</p>
<blockquote>
<h3 id="内联元素居中方案"><a href="#内联元素居中方案" class="headerlink" title="内联元素居中方案"></a>内联元素居中方案</h3><p><strong>水平居中设置：</strong><br>1.行内元素</p>
<ul>
<li>设置 text-align:center；</li>
</ul>
<p>2.Flex布局</p>
<ul>
<li>设置display:flex;justify-content:center;(灵活运用,支持Chroime，Firefox，IE9+)</li>
</ul>
<p><strong>垂直居中设置：</strong><br>1.父元素高度确定的单行文本（内联元素）</p>
<ul>
<li>设置 height = line-height；</li>
</ul>
<p>2.父元素高度确定的多行文本（内联元素）</p>
<ul>
<li>a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle；</li>
<li>b:先设置 display:table-cell 再设置 vertical-align:middle；<h3 id="块级元素居中方案"><a href="#块级元素居中方案" class="headerlink" title="块级元素居中方案"></a>块级元素居中方案</h3><strong>水平居中设置：</strong><br>1.定宽块状元素</li>
<li>设置 左右 margin 值为 auto；</li>
</ul>
<p>2.不定宽块状元素</p>
<ul>
<li>a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto；</li>
<li>b:给该元素设置 displa:inine 方法；</li>
<li>c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%；</li>
</ul>
<p><strong>垂直居中设置：</strong></p>
<ul>
<li>使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性;</li>
<li>利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了;</li>
<li>利用display:table-cell属性使内容垂直居中;</li>
<li>使用css3的新属性transform:translate(x,y)属性;</li>
<li>使用:before元素;</li>
</ul>
</blockquote>
<p> 5.写出几种IE6 BUG的解决方法</p>
<blockquote>
<ul>
<li>双边距BUG float引起的 使用display</li>
<li>3像素问题 使用float引起的 使用dislpay:inline -3px</li>
<li>超链接hover 点击后失效 使用正确的书写顺序 link visited hover active</li>
<li>Ie z-index问题 给父级添加position:relative</li>
<li>Png 透明 使用js代码 改</li>
<li>Min-height 最小高度 ！Important 解决’</li>
<li>select 在ie6下遮盖 使用iframe嵌套</li>
<li>为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）</li>
</ul>
</blockquote>
<p> 6.对于SASS或是Less的了解程度？喜欢那个？</p>
<blockquote>
<ul>
<li>语法介绍</li>
</ul>
</blockquote>
<p> 7.Bootstrap了解程度</p>
<blockquote>
<ul>
<li>特点，排版，插件的使用;</li>
</ul>
</blockquote>
<p> 8.页面导入样式时，使用link和@import有什么区别？</p>
<blockquote>
<ul>
<li>link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</li>
<li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li>
<li>import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</li>
</ul>
</blockquote>
<p> 9.介绍一下CSS的盒子模型？</p>
<blockquote>
<ul>
<li>有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;</li>
<li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</li>
</ul>
</blockquote>
<p> 10.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
<blockquote>
<ul>
<li>id选择器（ # myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div, h1, p）</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（ * ）</li>
<li>属性选择器（a[rel = “external”]）</li>
<li>伪类选择器（a: hover, li: nth - child）</li>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height ;</li>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>优先级为:<pre><code>!important &gt;  id &gt; class &gt; tag
important 比 内联优先级高
</code></pre></li>
</ul>
</blockquote>
<p> 11.CSS3有哪些新特性？</p>
<blockquote>
<ul>
<li>CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），<br>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li>
<li>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>增加了更多的CSS选择器  多背景 rgba</li>
</ul>
</blockquote>
<h2 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a>JavaScript面试题</h2><p> 1.javascript的typeof返回哪些数据类型</p>
<blockquote>
<ul>
<li>Ｏbject number function boolean underfind;</li>
</ul>
</blockquote>
<p> 2.例举3种强制类型转换和2种隐式类型转换?</p>
<blockquote>
<ul>
<li>强制（parseInt,parseFloat,number）隐式（== – ===）；</li>
</ul>
</blockquote>
<p> 3.数组方法pop() push() unshift() shift()</p>
<blockquote>
<ul>
<li>Push()尾部添加 pop()尾部删除</li>
<li>Unshift()头部添加 shift()头部删除</li>
</ul>
</blockquote>
<p> 4.ajax请求的时候get 和post方式的区别?</p>
<blockquote>
<ul>
<li>一个在url后面 一个放在虚拟载体里面<br>有大小限制</li>
<li>安全问题<br>应用不同 一个是论坛等只需要请求的，一个是类似修改密码的;</li>
</ul>
</blockquote>
<p> 5.call和apply的区别</p>
<blockquote>
<ul>
<li>Object.call(this,obj1,obj2,obj3)</li>
<li>Object.apply(this,arguments)</li>
</ul>
</blockquote>
<p> 6.ajax请求时，如何解释json数据</p>
<blockquote>
<ul>
<li>使用eval parse,鉴于安全性考虑 使用parse更靠谱;</li>
</ul>
</blockquote>
<p> 7.事件委托是什么</p>
<blockquote>
<ul>
<li>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</li>
</ul>
</blockquote>
<p> 8.闭包是什么，有什么特性，对页面有什么影响?简要介绍你理解的闭包</p>
<blockquote>
<ul>
<li>闭包就是能够读取其他函数内部变量的函数。</li>
</ul>
</blockquote>
<p> 9.添加 删除 替换 插入到某个接点的方法</p>
<blockquote>
<p>obj.appendChidl()<br>obj.innersetBefore<br>obj.replaceChild<br>obj.removeChild</p>
</blockquote>
<p> 10.说一下什么是javascript的同源策略？</p>
<blockquote>
<ul>
<li>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合</li>
</ul>
</blockquote>
<p> 11.编写一个b继承a的方法;<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(name)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;alert(<span class="keyword">this</span>.name+” say Hello!”);&#125;;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(name,id)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.temp = A;</div><div class="line">    <span class="keyword">this</span>.temp(name);        <span class="comment">//相当于new A();</span></div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.temp;       </div><div class="line">     <span class="keyword">this</span>.id = id;   </div><div class="line">    <span class="keyword">this</span>.checkId = <span class="function"><span class="keyword">function</span><span class="params">(ID)</span></span>&#123;alert(<span class="keyword">this</span>.id==ID)&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 12.如何阻止事件冒泡和默认事件<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (e &amp;&amp; e.stopPropagation)</div><div class="line">        e.stopPropagation()</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">window</span>.event.cancelBubble=<span class="literal">true</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p> 13.下面程序执行后弹出什么样的结果?</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.a)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fn.prototype = &#123;</div><div class="line">    b: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = <span class="number">20</span>;</div><div class="line">        alert(<span class="keyword">this</span>.a);</div><div class="line">    &#125;,</div><div class="line">    c: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = <span class="number">30</span>;</div><div class="line">        alert(<span class="keyword">this</span>.a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myfn = <span class="keyword">new</span> fn();</div><div class="line">myfn.b();</div><div class="line">myfn.c();</div></pre></td></tr></table></figure>
<p> 14.谈谈This对象的理解。</p>
<blockquote>
<p>this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。<br>  但是有一个总原则，那就是this指的是调用函数的那个对象。<br>  this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象</p>
</blockquote>
<p> 15.下面程序的结果<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="title">fun</span><span class="params">(n,o)</span></span> &#123;</div><div class="line">  console.log(o)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span>:<span class="title">function</span><span class="params">(m)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(m,n)</span></span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>;  a.<span class="keyword">fun</span>(<span class="number">1</span>);  a.<span class="keyword">fun</span>(<span class="number">2</span>);  a.<span class="keyword">fun</span>(<span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>).<span class="keyword">fun</span>(<span class="number">2</span>).<span class="keyword">fun</span>(<span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> c = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>);  c.<span class="keyword">fun</span>(<span class="number">2</span>);  c.<span class="keyword">fun</span>(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>//答案：<br>//a: undefined,0,0,0<br>//b: undefined,0,1,2<br>//c: undefined,0,1,1</p>
</blockquote>
<p> 16.下面程序的输出结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">'Jack'</span>;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p> 17.了解Node么？Node的使用场景都有哪些？</p>
<blockquote>
<ul>
<li>高并发、聊天、实时消息推送</li>
</ul>
</blockquote>
<p> 18.介绍下你最常用的一款框架</p>
<blockquote>
<ul>
<li>jquery,rn,angular等;</li>
</ul>
</blockquote>
<p> 19.对于前端自动化构建工具有了解吗？简单介绍一下</p>
<blockquote>
<ul>
<li>Gulp,Grunt等；</li>
</ul>
</blockquote>
<p> 20.介绍一下你了解的后端语言以及掌握程度</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><br><br> 1.对Node的优点和缺点提出了自己的看法？</p>
<blockquote>
<p>(优点）<br>     因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>     因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。<br>（缺点）<br>     Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，<br>    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p>
</blockquote>
<p> 2.你有哪些性能优化的方法？</p>
<blockquote>
<p>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br> （2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>（4） 当需要设置的样式很多时设置className而不是直接操作style。<br>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。<br>（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示div+css布局慢。对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</p>
<p>3.http状态码有那些？分别代表是什么意思？<br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401    当前请求需要用户验证 403    服务器已经理解请求，但是拒绝执行它。<br>500-599 用于支持服务器错误。 503 – 服务不可用<br>4.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p>
<ul>
<li>查找浏览器缓存</li>
<li>DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求</li>
<li>进行HTTP协议会话</li>
<li>客户端发送报头(请求报头)</li>
<li>文档开始下载</li>
<li>文档树建立，根据标记请求所需指定MIME类型的文件</li>
<li>文件显示</li>
<li>浏览器这边做的工作大致分为以下几步：</li>
<li>加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。</li>
<li>解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等）</li>
</ul>
</blockquote>
<p> 5.你常用的开发工具是什么，为什么？</p>
<blockquote>
<ul>
<li>Sublime,Atom,Nodepad++;</li>
</ul>
</blockquote>
<p> 6.说说最近最流行的一些东西吧？常去哪些网站？</p>
<blockquote>
<ul>
<li>Node.js、MVVM、React-native,Angular,Weex等</li>
<li>CSDN,Segmentfault,博客园,掘金,Stackoverflow等</li>
</ul>
</blockquote>
<p> 7.介绍下你的项目（如果有的话）？并说一下在做这个项目中运用的技术以及遇到的难题是如何解决的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML面试题&quot;&gt;&lt;a href=&quot;#HTML面试题&quot; class=&quot;headerlink&quot; title=&quot;HTML面试题&quot;&gt;&lt;/a&gt;HTML面试题&lt;br&gt;&lt;br&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;XHTML和HTML有什么区别&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言&lt;br&gt;最主要的不同：&lt;/li&gt;
&lt;li&gt;XHTML 元素必须被正确地嵌套。&lt;/li&gt;
&lt;li&gt;XHTML 元素必须被关闭。&lt;/li&gt;
&lt;li&gt;标签名必须用小写字母。&lt;/li&gt;
&lt;li&gt;XHTML 文档必须拥有根元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="http" scheme="http://damonare.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Javascript填坑史</title>
    <link href="http://damonare.github.io/2016/09/05/javascript%E5%A1%AB%E5%9D%91%E5%8F%B2/"/>
    <id>http://damonare.github.io/2016/09/05/javascript填坑史/</id>
    <published>2016-09-05T08:08:22.180Z</published>
    <updated>2016-09-06T04:06:26.459Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明：</strong>&nbsp;&nbsp;这是笔者平时积累的一些觉得比较有意思或是比较有难度的JavaScript题目理解和心得，会保持长期更新。</p>
<a id="more"></a>
<h3 id="1-setTimeout和setInterval深入理解"><a href="#1-setTimeout和setInterval深入理解" class="headerlink" title="1.setTimeout和setInterval深入理解"></a>1.setTimeout和setInterval深入理解</h3><p>在<a href="https://segmentfault.com/a/1190000004034739" target="_blank" rel="external">setTimeout和setInterval深入理解</a>这篇博客里笔者曾做过总结，我们知道JavaScript试单线程的产物，两个函数就是利用了插入代码的方式实现了伪异步，和AJAX的原理实际上是一样的。下面来看下这个例子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console<span class="selector-class">.log</span>(<span class="string">"1"</span>);</div><div class="line"><span class="selector-tag">setTimeout</span>(function()&#123;</div><div class="line">		console<span class="selector-class">.log</span>(<span class="string">"3"</span>)</div><div class="line">	&#125;,<span class="number">0</span>);</div><div class="line">	<span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="string">"2"</span>);</div></pre></td></tr></table></figure>
<p>结果：控制台依次输出1,2,3;</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;alert(<span class="string">'can you see me?'</span>);&#125;,<span class="number">1000</span>);</div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你觉得这段代码的执行结果是什么呢？答案是，alert永远不会出现。<br>&nbsp;&nbsp;&nbsp;&nbsp;这是为什么呢？因为，while这段代码没有执行完，所以插入在后面的代码便永远不会执行。<br>综上所述，其实JS终归是单线程产物。无论如何“异步”都不可能突破单线程这个障碍。所以许多的“异步调用”（包括Ajax）事实上也只是“伪异步”而已。只要理解了这么一个概念，也许理解setTimeout和setInterval也就不难了。</p>
<h3 id="2-闭包初探小题"><a href="#2-闭包初探小题" class="headerlink" title="2. 闭包初探小题"></a>2. 闭包初探小题</h3><p>在<a href="https://segmentfault.com/a/1190000004093058" target="_blank" rel="external">JavaScript闭包初探</a>这篇博客里面进行了初步探讨，有几个小题个人觉得还是比较有意思的:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　name : <span class="string">"My Object"</span>,</div><div class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//The Window</span></div></pre></td></tr></table></figure></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">　  <span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　name : <span class="string">"My Object"</span>,</div><div class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> that.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//My Object</span></div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function <span class="function"><span class="title">fun</span><span class="params">(n,o)</span></span> &#123;</div><div class="line">  console.log(o)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span>:<span class="title">function</span><span class="params">(m)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(m,n)</span></span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>;  a.<span class="keyword">fun</span>(<span class="number">1</span>);  a.<span class="keyword">fun</span>(<span class="number">2</span>);  a.<span class="keyword">fun</span>(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> b = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>).<span class="keyword">fun</span>(<span class="number">2</span>).<span class="keyword">fun</span>(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div><div class="line"><span class="keyword">var</span> c = <span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>);  c.<span class="keyword">fun</span>(<span class="number">2</span>);  c.<span class="keyword">fun</span>(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></div></pre></td></tr></table></figure>
<blockquote>
<p>//问:三行a,b,c的输出分别是什么？</p>
</blockquote>
<p><strong>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</strong></p>
<blockquote>
<p>//答案：<br>//a: undefined,0,0,0<br>//b: undefined,0,1,2<br>//c: undefined,0,1,1</p>
</blockquote>
<h3 id="3-Array-map-Number-parseInt"><a href="#3-Array-map-Number-parseInt" class="headerlink" title="3. Array/map,Number/parseInt"></a>3. Array/map,Number/parseInt</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].<span class="built_in">map</span>(<span class="built_in">parseInt</span>)<span class="comment">//求输出结果</span></div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值<br>其中回调函数接受三个参数 currentValue, index, arrary;而题目中, map只传入了回调函数–parseInt.其次, parseInt 只接受两个两个参数 string, radix(基数). radix的合法区间是2-36. 0或是默认是10.所以本题即问</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>后两者参数不合法.所以答案是：[1, NaN, NaN]；</p>
<h3 id="4-nbsp-0-1-0-2-0-3和9999999999999999-10000000000000000"><a href="#4-nbsp-0-1-0-2-0-3和9999999999999999-10000000000000000" class="headerlink" title="4.&nbsp;0.1+0.2!=0.3和9999999999999999 == 10000000000000000;"></a>4.&nbsp;0.1+0.2!=0.3和9999999999999999 == 10000000000000000;</h3><blockquote>
<p>根据语言规范，JavaScript 采用“IEEE 754 标准定义的双精度64位格式”（”double-precision 64-bit format IEEE 754 values”）表示数字。据此我们能得到一个有趣的结论，和其他编程语言（如 C 和 Java）不同，JavaScript 不区分整数值和浮点数值，所有数字在 JavaScript 中均用浮点数值表示，所以在进行数字运算的时候要特别注意。<a href="http://demon.tw/copy-paste/javascript-precision.html" target="_blank" rel="external">精度丢失</a>看看下面的例子:</p>
</blockquote>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在具体实现时，整数值通常被视为32位整型变量，在个别实现（如某些浏览器）中也以32位整型变量的形式进行存储，直到它被用于执行某些32位整型不支持的操作，这是为了便于进行位操作。大整数精度在2的53次方以内是不会丢失的，也就是说浏览器能精确计算Math.pow(2,53)以内所有的数，小数精度，当十进制小数的二进制表示的有限数字不超过 52 位时，在 JavaScript 里也是可以精确存储的。\<br>解决办法：Math.round( (.1+.2)*100)/100;</p>
</blockquote>
<h3 id="5-1-gt-2-gt-3-3-gt-2-gt-1"><a href="#5-1-gt-2-gt-3-3-gt-2-gt-1" class="headerlink" title="5. [1&gt;2&gt;3,3&gt;2&gt;1]"></a>5. [1&gt;2&gt;3,3&gt;2&gt;1]</h3><p>&nbsp;&nbsp;此题会让人误以为是2&gt;1&amp;&amp;2&lt;3,其实不是的，这个题等价于</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>&lt;<span class="number">2</span>=&gt;<span class="keyword">true</span>;</div><div class="line"><span class="keyword">true</span>&lt;<span class="number">3</span>=&gt;<span class="number">1</span>&lt;<span class="number">3</span>=&gt;<span class="keyword">true</span>;</div><div class="line"><span class="number">3</span>&lt;<span class="number">2</span>=&gt;<span class="keyword">true</span>;</div><div class="line"><span class="keyword">false</span>&lt;<span class="number">1</span>=&gt;<span class="number">0</span>&lt;<span class="number">1</span>=&gt;<span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p><strong>答案：[true,true]</strong><br>&nbsp;&nbsp;这个题的重点是对于运算符的理解，一是javascript对于不同类型数值的比较规则，详见<a href="http://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="external">js比较表</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="external">javascript相等性判断</a>；二是对于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_operator" target="_blank" rel="external">比较操作符</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators" target="_blank" rel="external">赋值运算符</a>的理解，即一个自左向右一个自右向左~</p>
<h3 id="6-浏览器懵逼史（1）"><a href="#6-浏览器懵逼史（1）" class="headerlink" title="6. 浏览器懵逼史（1）"></a>6. 浏览器懵逼史（1）</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>.tostring<span class="comment">;</span></div><div class="line"><span class="number">3</span>..toString<span class="comment">;</span></div><div class="line"><span class="number">3</span>...toString<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这个题感觉脑洞很大啊~先说答案：error,’3’,error;<br>可如果是</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a=<span class="number">3</span><span class="comment">;</span></div><div class="line">a.toString<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>却又合法了答案就是’3’;<br>为啥呢？<br>因为在JS中1.1,1.,.1都是合法数字啊！那么在解析3.toString的时候到底是这是个数字呢，还是方法调用呢？浏览器就懵逼了呗，只能抛出一个error,所以说感觉此题就是在戏耍浏览器……</p>
<h3 id="7-声明提升"><a href="#7-声明提升" class="headerlink" title="7. 声明提升"></a>7. 声明提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'World!'</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">'Jack'</span>;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye '</span> + name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>答案是什么呢…笔者第一次做的时候傻傻的觉得是Hello,world…实则不然，正确答案是:Goodbye Jack;<br>为什么呢，声明提升…上述代码相当于下面的代码：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">name</span> = <span class="string">'World!'</span>;</div><div class="line">(function () &#123;</div><div class="line">    var <span class="built_in">name</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">typeof</span> <span class="built_in">name</span> === <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="built_in">name</span> = <span class="string">'Jack'</span>;</div><div class="line">        console.<span class="built_in">log</span>(<span class="string">'Goodbye '</span> + <span class="built_in">name</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        console.<span class="built_in">log</span>(<span class="string">'Hello '</span> + <span class="built_in">name</span>);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h3 id="8-坑爹史（1）"><a href="#8-坑爹史（1）" class="headerlink" title="8. 坑爹史（1）"></a>8. 坑爹史（1）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">0</span>];</div><div class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</div><div class="line">  <span class="built_in">console</span>.log(a == <span class="literal">true</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"wut"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者们你们觉得此题答案是什么呢？true?因为[0]被看做Boolean是被认为是true，理所当然的推出来[0]==true,控制台输出true…看似没错，然而并不是这样滴~[0]这个玩意儿在单独使用的时候是被认为是true的，但用作比较的时候它是false…所以正确答案是false；不信的话，F12控制台输出[0]==false；看是不是true……</p>
<p>###9. 坑爹史（2）</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span>+ - + + + - + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这题应该是等同于：（倒着看）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + (<span class="name">a</span>)  =&gt; <span class="number">2</span></div><div class="line">a = - (<span class="name">b</span>) =&gt; <span class="number">1</span></div><div class="line">b = + (<span class="name">c</span>) =&gt; <span class="number">-1</span></div><div class="line">c = + (<span class="name">d</span>) =&gt; <span class="number">-1</span></div><div class="line">d = + (<span class="name">e</span>) =&gt; <span class="number">-1</span></div><div class="line">e = + (<span class="name">f</span>) =&gt; <span class="number">-1</span></div><div class="line">f = - (<span class="name">g</span>) =&gt; <span class="number">-1</span></div><div class="line">g = + <span class="number">1</span>   =&gt; <span class="number">1</span></div></pre></td></tr></table></figure>
<p>答案是2</p>
<h3 id="10-坑爹史（3）"><a href="#10-坑爹史（3）" class="headerlink" title="10. 坑爹史（3）"></a>10. 坑爹史（3）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sidEffecting</span>(<span class="params">ary</span>) </span>&#123;</div><div class="line">  ary[<span class="number">0</span>] = ary[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>) </span>&#123;</div><div class="line">  c = <span class="number">10</span></div><div class="line">  sidEffecting(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line">bar(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>此题涉及ES6语法，实在坑的不行…<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">arguments</a><br>首先 The arguments object is an Array-like object corresponding to the arguments passed to a function.也就是说 arguments 是一个 object, c 就是 arguments<a href="https://segmentfault.com/a/1190000004093058" target="_blank" rel="external">2</a>, 所以对于 c 的修改就是对 arguments<a href="https://segmentfault.com/a/1190000004093058" target="_blank" rel="external">2</a> 的修改.<br>所以答案是 21.<br>然而!!!!!!<br>当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了…..请看:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sidEffecting</span>(<span class="params">ary</span>) </span>&#123;</div><div class="line">  ary[<span class="number">0</span>] = ary[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c=3</span>) </span>&#123;</div><div class="line">  c = <span class="number">10</span></div><div class="line">  sidEffecting(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line">bar(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>答案是12…<br>请读者细细体会!!</p>
<h3 id="11-坑爹史（4）"><a href="#11-坑爹史（4）" class="headerlink" title="11. 坑爹史（4）"></a>11. 坑爹史（4）</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[,,,]</span><span class="selector-class">.join</span>(<span class="string">", "</span>)</div></pre></td></tr></table></figure>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">[,,,]</span> =&gt; <span class="string">[undefined × 3]</span></div></pre></td></tr></table></figure>
<p>因为javascript 在定义数组的时候允许最后一个元素后跟一个,, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)<br>答案: “, , “</p>
<h3 id="12-浏览器懵逼史-2"><a href="#12-浏览器懵逼史-2" class="headerlink" title="12. 浏览器懵逼史(2)"></a>12. 浏览器懵逼史(2)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="class"><span class="keyword">class</span>: <span class="type">"Animal"</span>, <span class="type">name: 'Fido'&#125;;</span></span></div><div class="line">a.<span class="keyword">class</span></div></pre></td></tr></table></figure>
<p>这个题比较流氓.. 因为是浏览器相关, class是个保留字(现在是个关键字了);Fuck!<br>所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a[‘class’]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&amp;nbsp;&amp;nbsp;这是笔者平时积累的一些觉得比较有意思或是比较有难度的JavaScript题目理解和心得，会保持长期更新。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
